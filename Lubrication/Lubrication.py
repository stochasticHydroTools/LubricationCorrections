'''
Class to handle Lubrication corrections
'''
import numpy as np
from scipy import interpolate
import scipy.spatial as spatial
import scipy.sparse.linalg as spla
from scipy.linalg import cholesky
from scipy.linalg import solve_triangular
from functools import partial
import copy
import inspect
import time
import utils
import sys
from LLC import LLC
from mobility import mobility as mob
import pyamg
import scipy.sparse as sp
from sksparse.cholmod import cholesky

class Lubrication(object):
  '''
  Small class to handle a single body.
  '''  
  def __init__(self, bodies):
    '''
    Constructor. Take arguments like ...
    '''
    # Location as np.array.shape = 3
    self.bodies = bodies
    self.mob_scalars_MB = None
    self.res_scalars_wall_MB_1 = None
    self.mob_scalars_wall_MB = None
    self.mob_scalars_WS = None
    self.mob_scalars_JO = None
    self.MB_Fn = None
    self.MB_wall_Fn = None
    self.MB_res_wall_Fn = None
    self.WS_Fn = None
    
    # for PC
    self.Lub_Chol_Blocks = None
    self.Mob_Inv_Blocks = None
    
    #if domain is a 'single_wall'
    self.mobility_trans_times_force_wall = mob.single_wall_mobility_trans_times_force_numba
    self.mobility_trans_times_torque_wall = mob.single_wall_mobility_trans_times_torque_numba
    self.mobility_rot_times_force_wall = mob.single_wall_mobility_rot_times_force_numba
    self.mobility_rot_times_torque_wall = mob.single_wall_mobility_rot_times_torque_numba
    #if domain is a 'no_wall'
    self.mobility_trans_times_force = mob.no_wall_mobility_trans_times_force_numba
    self.mobility_trans_times_torque = mob.no_wall_mobility_trans_times_torque_numba
    self.mobility_rot_times_force = mob.no_wall_mobility_rot_times_force_numba
    self.mobility_rot_times_torque = mob.no_wall_mobility_rot_times_torque_numba
    
    
  def project_to_periodic_image(self, r, L):
    '''
    Project a vector r to the minimal image representation
    centered around (0,0,0) and of size L=(Lx, Ly, Lz). If 
    any dimension of L is equal or smaller than zero the 
    box is assumed to be infinite in that direction.
    '''
    if L is None:
      exit()
      
    if L is not None:
      for i in range(3):
	if(L[i] > 0):
	  r[i] = r[i] - int(r[i] / L[i] + 0.5 * (int(r[i]>0) - int(r[i]<0))) * L[i]
    #print r
    return r
  
  def load_WS_coefficient_interp_data(self):
    self.mob_scalars_WS = np.loadtxt("./Resistance_Coefs/mob_scalars_WS.txt") #res_scalars_WS.txt
    
  def load_JO_coefficient_interp_data(self):
    self.mob_scalars_JO = np.loadtxt("./Resistance_Coefs/res_scalars_JO.txt")
    
  def load_MB_coefficient_interp_data(self,Nblobs):
    self.mob_scalars_MB = np.loadtxt("./Resistance_Coefs/res_scalars_MB_1.txt")
    #self.mob_scalars_MB = np.loadtxt("./Resistance_Coefs/mob_scalars_MB_" + str(Nblobs) + ".txt")
    
  def load_MB_wall_interp_data(self):
    self.mob_scalars_wall_MB = np.loadtxt("./Resistance_Coefs/mob_scalars_wall_MB_2562.txt")
    
  def load_res_MB_wall_interp_data(self):
    self.res_scalars_wall_MB_1 = np.loadtxt("./Resistance_Coefs/res_scalars_wall_MB.txt")
    
  def rat45_eval(self, pq, x):
    rat_f = (pq[0]*x**4 + pq[1]*x**3 + pq[2]*x**2 + pq[3]*x + pq[4])/(x**5 + pq[5]*x**4 + pq[6]*x**3 + pq[7]*x**2 + pq[8]*x + pq[9])
    return rat_f
    
  def set_WS_coefficient_interp_functions(self, kind='linear'):
    mob_scalars_WS_11 = self.mob_scalars_WS[::2, :]
    mob_scalars_WS_12 = self.mob_scalars_WS[1::2, :]
    d_s = mob_scalars_WS_11[:, 0]
    x11a_WS = interpolate.interp1d(d_s, mob_scalars_WS_11[:,1], kind=kind)
    x12a_WS = interpolate.interp1d(d_s, mob_scalars_WS_12[:,1], kind=kind)
    y11a_WS = interpolate.interp1d(d_s, mob_scalars_WS_11[:,2], kind=kind)
    y12a_WS = interpolate.interp1d(d_s, mob_scalars_WS_12[:,2], kind=kind)
    y11b_WS = interpolate.interp1d(d_s, mob_scalars_WS_11[:,3], kind=kind)
    y12b_WS = interpolate.interp1d(d_s, mob_scalars_WS_12[:,3], kind=kind)
    x11c_WS = interpolate.interp1d(d_s, mob_scalars_WS_11[:,4], kind=kind)
    x12c_WS = interpolate.interp1d(d_s, mob_scalars_WS_12[:,4], kind=kind)
    y11c_WS = interpolate.interp1d(d_s, mob_scalars_WS_11[:,5], kind=kind)
    y12c_WS = interpolate.interp1d(d_s, mob_scalars_WS_12[:,5], kind=kind)
    self.WS_Fn = [x11a_WS, x12a_WS, y11a_WS, y12a_WS, y11b_WS, y12b_WS, x11c_WS, x12c_WS, y11c_WS, y12c_WS]
    
  def set_JO_coefficient_interp_functions(self, kind='linear'):
    mob_scalars_JO_11 = self.mob_scalars_JO[::2, :]
    mob_scalars_JO_12 = self.mob_scalars_JO[1::2, :]
    d_s = mob_scalars_JO_11[:, 0]
    x11a_JO = interpolate.interp1d(d_s, mob_scalars_JO_11[:,1], kind=kind)
    x12a_JO = interpolate.interp1d(d_s, mob_scalars_JO_12[:,1], kind=kind)
    y11a_JO = interpolate.interp1d(d_s, mob_scalars_JO_11[:,2], kind=kind)
    y12a_JO = interpolate.interp1d(d_s, mob_scalars_JO_12[:,2], kind=kind)
    y11b_JO = interpolate.interp1d(d_s, mob_scalars_JO_11[:,3], kind=kind)
    y12b_JO = interpolate.interp1d(d_s, mob_scalars_JO_12[:,3], kind=kind)
    x11c_JO = interpolate.interp1d(d_s, mob_scalars_JO_11[:,4], kind=kind)
    x12c_JO = interpolate.interp1d(d_s, mob_scalars_JO_12[:,4], kind=kind)
    y11c_JO = interpolate.interp1d(d_s, mob_scalars_JO_11[:,5], kind=kind)
    y12c_JO = interpolate.interp1d(d_s, mob_scalars_JO_12[:,5], kind=kind)
    self.JO_Fn = [x11a_JO, x12a_JO, y11a_JO, y12a_JO, y11b_JO, y12b_JO, x11c_JO, x12c_JO, y11c_JO, y12c_JO]
  
  def set_MB_coefficient_interp_functions(self, kind='linear'):
    mob_scalars_MB_11 = self.mob_scalars_MB[::2, :]
    mob_scalars_MB_12 = self.mob_scalars_MB[1::2, :]
    d_s = mob_scalars_MB_11[:, 0]
    x11a_MB = interpolate.interp1d(d_s, mob_scalars_MB_11[:,1], kind=kind)
    x12a_MB = interpolate.interp1d(d_s, mob_scalars_MB_12[:,1], kind=kind)
    y11a_MB = interpolate.interp1d(d_s, mob_scalars_MB_11[:,2], kind=kind)
    y12a_MB = interpolate.interp1d(d_s, mob_scalars_MB_12[:,2], kind=kind)
    y11b_MB = interpolate.interp1d(d_s, mob_scalars_MB_11[:,3], kind=kind)
    y12b_MB = interpolate.interp1d(d_s, mob_scalars_MB_12[:,3], kind=kind)
    x11c_MB = interpolate.interp1d(d_s, mob_scalars_MB_11[:,4], kind=kind)
    x12c_MB = interpolate.interp1d(d_s, mob_scalars_MB_12[:,4], kind=kind)
    y11c_MB = interpolate.interp1d(d_s, mob_scalars_MB_11[:,5], kind=kind)
    y12c_MB = interpolate.interp1d(d_s, mob_scalars_MB_12[:,5], kind=kind)
    self.MB_Fn = [x11a_MB, x12a_MB, y11a_MB, y12a_MB, y11b_MB, y12b_MB, x11c_MB, x12c_MB, y11c_MB, y12c_MB]
    
  def set_MB_wall_interp_functions(self, kind='linear'):
    d_s = self.mob_scalars_wall_MB[:, 0]
    xa_MB_wall = interpolate.interp1d(d_s, self.mob_scalars_wall_MB[:,1], kind=kind)
    ya_MB_wall = interpolate.interp1d(d_s, self.mob_scalars_wall_MB[:,2], kind=kind)
    yb_MB_wall = interpolate.interp1d(d_s, self.mob_scalars_wall_MB[:,3], kind=kind)
    xc_MB_wall = interpolate.interp1d(d_s, self.mob_scalars_wall_MB[:,4], kind=kind)
    yc_MB_wall = interpolate.interp1d(d_s, self.mob_scalars_wall_MB[:,5], kind=kind)
    self.MB_wall_Fn = [xa_MB_wall, ya_MB_wall, yb_MB_wall, xc_MB_wall, yc_MB_wall]
    
  def set_MB_res_wall_interp_functions(self, kind='linear'):
    d_s = self.res_scalars_wall_MB_1[:, 0]
    xa_MB_res_wall = interpolate.interp1d(d_s, self.res_scalars_wall_MB_1[:,1], kind=kind)
    ya_MB_res_wall = interpolate.interp1d(d_s, self.res_scalars_wall_MB_1[:,2], kind=kind)
    yb_MB_res_wall = interpolate.interp1d(d_s, self.res_scalars_wall_MB_1[:,3], kind=kind)
    xc_MB_res_wall = interpolate.interp1d(d_s, self.res_scalars_wall_MB_1[:,4], kind=kind)
    yc_MB_res_wall = interpolate.interp1d(d_s, self.res_scalars_wall_MB_1[:,5], kind=kind)
    self.MB_res_wall_Fn = [xa_MB_res_wall, ya_MB_res_wall, yb_MB_res_wall, xc_MB_res_wall, yc_MB_res_wall]


  def MB_Resist(self, r_norm):
    ''' 
    % WS_Resist computes the near-field lubrication resistance matrix for a pair of
    '''

    # compute the scalars. 
    X11A = self.MB_Fn[0](r_norm)
    X12A = self.MB_Fn[1](r_norm)
    Y11A = self.MB_Fn[2](r_norm)
    Y12A = self.MB_Fn[3](r_norm)
    Y11B = self.MB_Fn[4](r_norm)
    Y12B = self.MB_Fn[5](r_norm)
    X11C = self.MB_Fn[6](r_norm)
    X12C = self.MB_Fn[7](r_norm)
    Y11C = self.MB_Fn[8](r_norm)
    Y12C = self.MB_Fn[9](r_norm)
    
    
    Xa = np.array([[X11A, X12A], [X12A, X11A]])
    Ya = np.array([[Y11A, Y12A], [Y12A, Y11A]])
    Yb = np.array([[Y11B, -Y12B], [Y12B, -Y11B]])
    Xc = np.array([[X11C, X12C], [X12C, X11C]])
    Yc = np.array([[Y11C, Y12C], [Y12C, Y11C]])
    
    
    return Xa, Ya, Yb, Xc, Yc


  def WS_Resist(self, r_norm):
    ''' 
    % WS_Resist computes the near-field lubrication resistance matrix for a pair of
    '''

    # compute the scalars. 
    X11A = self.WS_Fn[0](r_norm)
    X12A = self.WS_Fn[1](r_norm)
    Y11A = self.WS_Fn[2](r_norm)
    Y12A = self.WS_Fn[3](r_norm)
    Y11B = self.WS_Fn[4](r_norm)
    Y12B = self.WS_Fn[5](r_norm)
    X11C = self.WS_Fn[6](r_norm)
    X12C = self.WS_Fn[7](r_norm)
    Y11C = self.WS_Fn[8](r_norm)
    Y12C = self.WS_Fn[9](r_norm)
    
    
    Xa = np.array([[X11A, X12A], [X12A, X11A]])
    Ya = np.array([[Y11A, Y12A], [Y12A, Y11A]])
    Yb = np.array([[Y11B, -Y12B], [Y12B, -Y11B]])
    Xc = np.array([[X11C, X12C], [X12C, X11C]])
    Yc = np.array([[Y11C, Y12C], [Y12C, Y11C]])
    
    
    return Xa, Ya, Yb, Xc, Yc
  
  def JO_Resist_interp(self, r_norm):
    ''' 
    % WS_Resist computes the near-field lubrication resistance matrix for a pair of
    '''
    # compute the scalars. 
    X11A = self.JO_Fn[0](r_norm)
    X12A = self.JO_Fn[1](r_norm)
    Y11A = self.JO_Fn[2](r_norm)
    Y12A = self.JO_Fn[3](r_norm)
    Y11B = self.JO_Fn[4](r_norm)
    Y12B = self.JO_Fn[5](r_norm)
    X11C = self.JO_Fn[6](r_norm)
    X12C = self.JO_Fn[7](r_norm)
    Y11C = self.JO_Fn[8](r_norm)
    Y12C = self.JO_Fn[9](r_norm)
    
    
    Xa = np.array([[X11A, X12A], [X12A, X11A]])
    Ya = np.array([[Y11A, Y12A], [Y12A, Y11A]])
    Yb = np.array([[Y11B, -Y12B], [Y12B, -Y11B]])
    Xc = np.array([[X11C, X12C], [X12C, X11C]])
    Yc = np.array([[Y11C, Y12C], [Y12C, Y11C]])
    
    
    return Xa, Ya, Yb, Xc, Yc


  def Lub_Resist_Wall(self, h, eta, a):
    ''' 
    % Description
    '''
    r_norm = h/a;
    r_hat = np.array([0., 0., 1.])
    epsilon = r_norm-1.0

    # compute the scalars. 
    if r_norm < 10.0:
      Xa = self.MB_wall_Fn[0](r_norm)
      Ya = self.MB_wall_Fn[1](r_norm)
      Yb = self.MB_wall_Fn[2](r_norm)
      Xc = self.MB_wall_Fn[3](r_norm)
      Yc = self.MB_wall_Fn[4](r_norm)
    else:
      Xa = 1.0 - (9.0/8.0)*(1.0/r_norm)
      Ya = 1.0 - (9.0/16.0)*(1.0/r_norm)
      Yb = 0.0
      Xc = 0.75
      Yc = 0.75
      

    Xa_asym = 1.0/epsilon - (1.0/5.0)*np.log(epsilon) + 0.971280
    Ya_asym = -(8.0/15.0)*np.log(epsilon) + 0.9588
    Yb_asym = -(-(1.0/10.0)*np.log(epsilon)-0.1895) - 0.4576*epsilon
    Xc_asym = 1.2020569 - 3.0*(np.pi**2/6.0-1.0)*epsilon
    Yc_asym = -2.0/5.0*np.log(epsilon) + 0.3817 + 1.4578*epsilon
    
    Xa_cutoff = 1.+0.1
    Ya_cutoff = 1.+0.01
    Yb_cutoff = 1.+0.1
    Xc_cutoff = 1.+0.01
    Yc_cutoff = 1.+0.1
    
    squeezeMat = np.outer(r_hat, r_hat)
    shearMat = np.eye(3) - squeezeMat
    vortMat = np.array([[0.0,    r_hat[2], -r_hat[1]],
                        [-r_hat[2], 0.0,    r_hat[0]],
                        [r_hat[1], -r_hat[0], 0.0]])
    
    
    # calculate the multiblob resistance matrix
    A_MB = ((Xa/(6.0*np.pi*eta*a))*squeezeMat + (Ya/(6.0*np.pi*eta*a))*shearMat) 
    B_MB = (Yb/(6.0*np.pi*eta*a**2))*vortMat
    C_MB = ((Xc/(6.0*np.pi*eta*a**3))*squeezeMat + (Yc/(6.0*np.pi*eta*a**3))*shearMat)

    
    Mobility_MB = np.block([[A_MB, B_MB], [B_MB.T, C_MB]])
    Resistance_MB = np.linalg.pinv(Mobility_MB)
    
    XA = (r_norm<Xa_cutoff)*Xa_asym * (6.0*np.pi*eta*a) + (r_norm>=Xa_cutoff)*Resistance_MB[2,2];
    YA = (r_norm<Ya_cutoff)*Ya_asym * (6.0*np.pi*eta*a) + (r_norm>=Ya_cutoff)*Resistance_MB[0,0];
    YB = (r_norm<Yb_cutoff)*Yb_asym * (8.0*np.pi*eta*a**2) + (r_norm>=Yb_cutoff)*Resistance_MB[4,0];
    XC = (r_norm<Xc_cutoff)*Xc_asym * (8.0*np.pi*eta*a**3) + (r_norm>=Xc_cutoff)*Resistance_MB[5,5];
    YC = (r_norm<Yc_cutoff)*Yc_asym * (8.0*np.pi*eta*a**3) + (r_norm>=Yc_cutoff)*Resistance_MB[3,3];
    
    
    XA = XA - (6.0*np.pi*eta*a) 
    YA = YA - (6.0*np.pi*eta*a)
    XC = XC - (8.0*np.pi*eta*a**3)
    YC = YC - (8.0*np.pi*eta*a**3)
    
    A = (XA*squeezeMat + YA*shearMat)
    B = YB*vortMat 
    C = (XC*squeezeMat + YC*shearMat)
    
    Resistance_wall = np.block([[A, B], [B.T, C]])
    
    return Resistance_wall
  
  
  def Lub_Resist_Wall_MB(self, h, eta, a):
    ''' 
    % Description
    '''
    r_norm = h/a;
    r_hat = np.array([0., 0., 1.])

    # compute the scalars. 
    if r_norm < 13.49:
      Xa = self.MB_res_wall_Fn[0](r_norm)
      Ya = self.MB_res_wall_Fn[1](r_norm)
      Yb = self.MB_res_wall_Fn[2](r_norm)
      Xc = self.MB_res_wall_Fn[3](r_norm)
      Yc = self.MB_res_wall_Fn[4](r_norm)
    else:
      Xa = 1.0/(1.0 - (9.0/8.0)*(1.0/r_norm))
      Ya = 1.0/(1.0 - (9.0/16.0)*(1.0/r_norm))
      Yb = 0.0
      Xc = 1.0/0.75
      Yc = 1.0/0.75



    Xa = Xa - 1 
    Ya = Ya - 1
    Xc = Xc - 1.0/0.75
    Yc = Yc - 1.0/0.75
    
    squeezeMat = np.outer(r_hat, r_hat)
    shearMat = np.eye(3) - squeezeMat
    vortMat = np.array([[0.0,    r_hat[2], -r_hat[1]],
                        [-r_hat[2], 0.0,    r_hat[0]],
                        [r_hat[1], -r_hat[0], 0.0]])
    
    XA = Xa * (6.0*np.pi*eta*a)
    YA = Ya * (6.0*np.pi*eta*a)
    YB = Yb * (6.0*np.pi*eta*a**2)
    XC = Xc * (6.0*np.pi*eta*a**3)
    YC = Yc * (6.0*np.pi*eta*a**3)
    
    A = (XA*squeezeMat + YA*shearMat)
    B = YB*vortMat 
    C = (XC*squeezeMat + YC*shearMat)
    
    Resistance_wall = np.block([[A, B], [B.T, C]])
    
    return Resistance_wall


  def Resist_Wall_MB_diag(self, r_d, eta, a):
    ''' 
    % Description
    '''
    r = r_d/a;
    r_norm = np.linalg.norm(r)
    r_hat = r/r_norm

    # compute the scalars. 
    Xa = self.MB_res_wall_Fn[0](r_norm)
    Ya = self.MB_res_wall_Fn[1](r_norm)
    Yb = self.MB_res_wall_Fn[2](r_norm)
    Xc = self.MB_res_wall_Fn[3](r_norm)
    Yc = self.MB_res_wall_Fn[4](r_norm)
    
    squeezeMat = np.outer(r_hat, r_hat)
    shearMat = np.eye(3) - squeezeMat
    vortMat = np.array([[0.0,    r_hat[2], -r_hat[1]],
                        [-r_hat[2], 0.0,    r_hat[0]],
                        [r_hat[1], -r_hat[0], 0.0]])
    
    XA = Xa * (6.0*np.pi*eta*a)
    YA = Ya * (6.0*np.pi*eta*a)
    YB = Yb * (6.0*np.pi*eta*a**2)
    XC = Xc * (6.0*np.pi*eta*a**3)
    YC = Yc * (6.0*np.pi*eta*a**3)
    
    A = (XA*squeezeMat + YA*shearMat)
    B = YB*vortMat 
    C = (XC*squeezeMat + YC*shearMat)
    
    Resistance_wall = np.block([[A, B], [B.T, C]])
    
    return Resistance_wall



  def AT_Resist(self, r_norm):
    ''' 
    % AT_Resist computes the near-field lubrication resistance matrix for a pair of
    % identical spheres from the scalars in Adam Townsend's paper and
    % Mathmatica code.
    '''
    epsilon = r_norm-2
    
    # compute the scalars. The fomular is from Adam Townsend's Mathmatica code.
    X11A = 0.995419E0+(0.25E0)*epsilon**(-1)+(0.225E0)*np.log(epsilon**(-1))+(0.267857E-1)*epsilon*np.log(epsilon**(-1))
    X12A = (-0.350153E0)+(-0.25E0)*epsilon**(-1)+(-0.225E0)*np.log(epsilon**(-1))+(-0.267857E-1)*epsilon*np.log(epsilon**(-1))
    Y11A = 0.998317E0+(0.166667E0)*np.log(epsilon**(-1))
    Y12A = (-0.273652E0)+(-0.166667E0)*np.log(epsilon**(-1))
    Y11B = (-0.666667E0)*(0.23892E0+(-0.25E0)*np.log(epsilon**(-1))+(-0.125E0)*epsilon*np.log(epsilon**(-1)))
    Y12B = (-0.666667E0)*((-0.162268E-2)+(0.25E0)*np.log(epsilon**(-1))+(0.125E0)*epsilon*np.log(epsilon**(-1)))
    X11C = 0.133333E1*(0.10518E1+(-0.125E0)*epsilon*np.log(epsilon**(-1)))
    X12C = 0.133333E1*((-0.150257E0)+(0.125E0)*epsilon*np.log(epsilon**(-1)))
    Y11C = 0.133333E1*(0.702834E0+(0.2E0)*np.log(epsilon**(-1))+(0.188E0)*epsilon*np.log(epsilon**(-1)))
    Y12C = 0.133333E1*((-0.27464E-1)+(0.5E-1)*np.log(epsilon**(-1))+(0.62E-1)*epsilon*np.log(epsilon**(-1)))
    
    Xa = np.array([[X11A, X12A], [X12A, X11A]])
    Ya = np.array([[Y11A, Y12A], [Y12A, Y11A]])
    Yb = np.array([[Y11B, -Y12B], [Y12B, -Y11B]])
    Xc = np.array([[X11C, X12C], [X12C, X11C]])
    Yc = np.array([[Y11C, Y12C], [Y12C, Y11C]])
    
    return Xa, Ya, Yb, Xc, Yc
  
  def JO_Resist(self, r_norm, type):
    ''' 
    % JO_Resist computes the near-field lubrication resistance matrix for a pair of
    % identical spheres from the scalars in James Swan's Mathmatica code 
    '''
    d = r_norm
    # compute the scalars. The fomular is from James Swan's Mathmatica code.
    if type==1:     # order 200
      X11A = 0.1E1+0.405348E60*d**(-200)+0.101346E60*d**(-198)+0.253388E59*d**(-196)+0.63353E58*d**(-194)+0.158397E58*d**(-192)+ 0.396032E57*d**(-190)+0.990177E56*d**(-188)+0.247569E56*d**( -186)+0.618987E55*d**(-184)+0.154763E55*d**(-182)+0.386949E54*  d**(-180)+0.967478E53*d**(-178)+0.241897E53*d**(-176)+ 0.604811E52*d**(-174)+0.15122E52*d**(-172)+0.378097E51*d**(-170)+0.945359E50*d**(-168)+0.23637E50*d**(-166)+0.591002E49* d**(-164)+0.14777E49*d**(-162)+0.369477E48*d**(-160)+ 0.923823E47*d**(-158)+0.230989E47*d**(-156)+0.57756E46*d**( -154)+0.144412E46*d**(-152)+0.361088E45*d**(-150)+0.902868E44*  d**(-148)+0.225755E44*d**(-146)+0.564484E43*d**(-144)+ 0.141146E43*d**(-142)+0.352929E42*d**(-140)+0.882486E41*d**( -138)+0.220663E41*d**(-136)+0.551765E40*d**(-134)+0.137969E40*  d**(-132)+0.344992E39*d**(-130)+0.862659E38*d**(-128)+ 0.215711E38*d**(-126)+0.539395E37*d**(-124)+0.134879E37*d**( -122)+0.337276E36*d**(-120)+0.843393E35*d**(-118)+0.210901E35*  d**(-116)+0.527389E34*d**(-114)+0.131883E34*d**(-112)+ 0.3298E33*d**(-110)+0.824745E32*d**(-108)+0.20625E32*d**(-106)+  0.515795E31*d**(-104)+0.128993E31*d**(-102)+0.3226E30*d**(-100)  +0.806805E29*d**(-98)+0.201781E29*d**(-96)+0.504663E28*d**(-94)  +0.12622E28*d**(-92)+0.31569E27*d**(-90)+0.789587E26*d**(-88)+  0.197489E26*d**(-86)+0.493961E25*d**(-84)+0.123551E25*d**(-82)+  0.309032E24*d**(-80)+0.772979E23*d**(-78)+0.193348E23*d**(-76)+  0.483638E22*d**(-74)+0.120981E22*d**(-72)+0.302642E21*d**(-70)+  0.757127E20*d**(-68)+0.189426E20*d**(-66)+0.473966E19*d**(-64)+  0.118604E19*d**(-62)+0.296821E18*d**(-60)+0.742915E17*d**(-58)+  0.185963E17*d**(-56)+0.465529E16*d**(-54)+0.116543E16*d**(-52)+  0.291765E15*d**(-50)+0.730412E14*d**(-48)+0.182845E14*d**(-46)+  0.457705E13*d**(-44)+0.114578E13*d**(-42)+0.286864E12*d**(-40)+  0.71845E11*d**(-38)+0.180034E11*d**(-36)+0.45149E10*d**(-34)+  0.11333E10*d**(-32)+0.284734E9*d**(-30)+0.715871E8*d**(-28)+  0.180017E8*d**(-26)+0.452419E7*d**(-24)+0.113542E7*d**(-22)+  0.284461E6*d**(-20)+0.712667E5*d**(-18)+0.179606E5*d**(-16)+  0.459856E4*d**(-14)+0.120073E4*d**(-12)+0.312669E3*d**(-10)+  0.774258E2*d**(-8)+0.187031E2*d**(-6)+0.58125E1*d**(-4)+ 0.225E1*d**(-2)
      X12A = (-0.202681E60)*d**(-199)+(-0.506749E59)*d**( -197)+(-0.126699E59)*d**(-195)+(-0.316777E58)*d**(-193)+( -0.792021E57)*d**(-191)+(-0.198025E57)*d**(-189)+(-0.495112E56)  *d**(-187)+(-0.123791E56)*d**(-185)+(-0.30951E55)*d**(-183)+(  -0.77386E54)*d**(-181)+(-0.193487E54)*d**(-179)+(-0.483771E53)*  d**(-177)+(-0.120957E53)*d**(-175)+(-0.302428E52)*d**(-173)+(  -0.756162E51)*d**(-171)+(-0.189064E51)*d**(-169)+(-0.472719E50)  *d**(-167)+(-0.118195E50)*d**(-165)+(-0.295526E49)*d**(-163)+(  -0.738916E48)*d**(-161)+(-0.184754E48)*d**(-159)+(-0.46195E47)*  d**(-157)+(-0.115504E47)*d**(-155)+(-0.288803E46)*d**(-153)+(  -0.722116E45)*d**(-151)+(-0.180557E45)*d**(-149)+(-0.451463E44)  *d**(-147)+(-0.112884E44)*d**(-145)+(-0.282258E43)*d**(-143)+(  -0.705766E42)*d**(-141)+(-0.176473E42)*d**(-139)+(-0.441264E41)  *d**(-137)+(-0.110337E41)*d**(-135)+(-0.275897E40)*d**(-133)+(  -0.689885E39)*d**(-131)+(-0.172508E39)*d**(-129)+(-0.431365E38)  *d**(-127)+(-0.107866E38)*d**(-125)+(-0.269729E37)*d**(-123)+(  -0.674489E36)*d**(-121)+(-0.168665E36)*d**(-119)+(-0.421774E35)  *d**(-117)+(-0.105472E35)*d**(-115)+(-0.263754E34)*d**(-113)+(  -0.659573E33)*d**(-111)+(-0.164942E33)*d**(-109)+(-0.412478E32)  *d**(-107)+(-0.103151E32)*d**(-105)+(-0.25796E31)*d**(-103)+(  -0.645108E30)*d**(-101)+(-0.161331E30)*d**(-99)+(-0.403466E29)*  d**(-97)+(-0.100903E29)*d**(-95)+(-0.252351E28)*d**(-93)+( -0.631125E27)*d**(-91)+(-0.157847E27)*d**(-89)+(-0.394792E26)*  d**(-87)+(-0.987446E25)*d**(-85)+(-0.246987E25)*d**(-83)+( -0.617804E24)*d**(-81)+(-0.154542E24)*d**(-79)+(-0.386596E23)*  d**(-77)+(-0.967135E22)*d**(-75)+(-0.241954E22)*d**(-73)+( -0.605333E21)*d**(-71)+(-0.151449E21)*d**(-69)+(-0.37892E20)* d**(-67)+(-0.948055E19)*d**(-65)+(-0.237204E19)*d**(-63)+( -0.59349E18)*d**(-61)+(-0.148494E18)*d**(-59)+(-0.371551E17)* d**(-57)+(-0.929719E16)*d**(-55)+(-0.232663E16)*d**(-53)+( -0.582331E15)*d**(-51)+(-0.145782E15)*d**(-49)+(-0.365052E14)*  d**(-47)+(-0.9144E13)*d**(-45)+(-0.229114E13)*d**(-43)+( -0.574221E12)*d**(-41)+(-0.143938E12)*d**(-39)+(-0.360806E11)*  d**(-37)+(-0.904289E10)*d**(-35)+(-0.226584E10)*d**(-33)+( -0.56761E9)*d**(-31)+(-0.142196E9)*d**(-29)+(-0.356445E8)*d**(  -27)+(-0.894878E7)*d**(-25)+(-0.225269E7)*d**(-23)+(-0.569168E6)  *d**(-21)+(-0.144329E6)*d**(-19)+(-0.366335E5)*d**(-17)+( -0.925019E4)*d**(-15)+(-0.231026E4)*d**(-13)+(-0.575416E3)*d**(  -11)+(-0.148662E3)*d**(-9)+(-0.416484E2)*d**(-7)+(-0.120938E2)*  d**(-5)+(-0.2375E1)*d**(-3)+(-0.15E1)*d**(-1) 
      Y11A = 0.1E1+ 0.267771E58*d**(-200)+0.676154E57*d**(-198)+0.170755E57*d**( -196)+0.431271E56*d**(-194)+0.108937E56*d**(-192)+0.275203E55*  d**(-190)+0.695318E54*d**(-188)+0.175699E54*d**(-186)+ 0.444027E53*d**(-184)+0.11223E53*d**(-182)+0.283705E52*d**( -180)+0.717274E51*d**(-178)+0.181369E51*d**(-176)+0.458675E50*  d**(-174)+0.116013E50*d**(-172)+0.293476E49*d**(-170)+ 0.742506E48*d**(-168)+0.187884E48*d**(-166)+0.475488E47*d**( -164)+0.120351E47*d**(-162)+0.304666E46*d**(-160)+0.771357E45*  d**(-158)+0.19532E45*d**(-156)+0.49465E44*d**(-154)+ 0.125288E44*d**(-152)+0.317381E43*d**(-150)+0.804109E42*d**( -148)+0.203757E42*d**(-146)+0.516389E41*d**(-144)+0.130892E41*  d**(-142)+0.331836E40*d**(-140)+0.841426E39*d**(-138)+ 0.213401E39*d**(-136)+0.541343E38*d**(-134)+0.137358E38*d**( -132)+0.348615E37*d**(-130)+0.885036E36*d**(-128)+0.224754E36*  d**(-126)+0.570944E35*d**(-124)+0.145087E35*d**(-122)+ 0.36882E34*d**(-120)+0.937907E33*d**(-118)+0.238597E33*d**( -116)+0.607199E32*d**(-114)+0.15458E32*d**(-112)+0.393666E31* d**(-110)+0.100287E31*d**(-108)+0.255561E30*d**(-106)+ 0.65143E29*d**(-104)+0.166093E29*d**(-102)+0.423581E28*d**( -100)+0.108048E28*d**(-98)+0.275671E27*d**(-96)+0.7035E26*d**(  -94)+0.179576E26*d**(-92)+0.458531E25*d**(-90)+0.117126E25*d**(  -88)+0.299329E24*d**(-86)+0.76542E23*d**(-84)+0.195868E23*d**(  -82)+0.501647E22*d**(-80)+0.128605E22*d**(-78)+0.330059E21*d**(  -76)+0.848074E20*d**(-74)+0.218173E20*d**(-72)+0.561935E19*d**(  -70)+0.144897E19*d**(-68)+0.373988E18*d**(-66)+0.966053E17*d**(  -64)+0.249681E17*d**(-62)+0.645508E16*d**(-60)+0.166899E16*d**(  -58)+0.431497E15*d**(-56)+0.111554E15*d**(-54)+0.288461E14*d**(  -52)+0.746499E13*d**(-50)+0.193511E13*d**(-48)+0.503082E12*d**(  -46)+0.131341E12*d**(-44)+0.344737E11*d**(-42)+0.910203E10*d**(  -40)+0.241644E10*d**(-38)+0.644077E9*d**(-36)+0.171927E9*d**(  -34)+0.458319E8*d**(-32)+0.121748E8*d**(-30)+0.322191E7*d**(  -28)+0.85194E6*d**(-26)+0.226612E6*d**(-24)+0.611923E5*d**(-22)  +0.169127E5*d**(-20)+0.480976E4*d**(-18)+0.140936E4*d**(-16)+  0.419821E3*d**(-14)+0.121272E3*d**(-12)+0.321186E2*d**(-10)+  0.869777E1*d**(-8)+0.359985E1*d**(-6)+0.181641E1*d**(-4)+ 0.5625E0*d**(-2)
      Y12A = (-0.134555E58)*d**(-199)+(-0.339785E57)*d**( -197)+(-0.858136E56)*d**(-195)+(-0.216749E56)*d**(-193)+( -0.54753E55)*d**(-191)+(-0.138328E55)*d**(-189)+(-0.349517E54)*  d**(-187)+(-0.883246E53)*d**(-185)+(-0.22323E53)*d**(-183)+( -0.564261E52)*d**(-181)+(-0.142649E52)*d**(-179)+(-0.360676E51)  *d**(-177)+(-0.912067E50)*d**(-175)+(-0.230674E50)*d**(-173)+(  -0.583489E49)*d**(-171)+(-0.147614E49)*d**(-169)+(-0.373497E48)  *d**(-167)+(-0.945163E47)*d**(-165)+(-0.239215E47)*d**(-163)+(  -0.605522E46)*d**(-161)+(-0.153296E46)*d**(-159)+(-0.388145E45)  *d**(-157)+(-0.982914E44)*d**(-155)+(-0.248941E44)*d**(-153)+(  -0.630577E43)*d**(-151)+(-0.15975E43)*d**(-149)+(-0.404768E42)*  d**(-147)+(-0.102574E42)*d**(-145)+(-0.259978E41)*d**(-143)+(  -0.659035E40)*d**(-141)+(-0.167093E40)*d**(-139)+(-0.423735E39)  *d**(-137)+(-0.107479E39)*d**(-135)+(-0.272677E38)*d**(-133)+(  -0.691965E37)*d**(-131)+(-0.175645E37)*d**(-129)+(-0.445981E36)  *d**(-127)+(-0.113274E36)*d**(-125)+(-0.2878E35)*d**(-123)+(  -0.731476E34)*d**(-121)+(-0.18598E34)*d**(-119)+(-0.473033E33)*  d**(-117)+(-0.120359E33)*d**(-115)+(-0.306353E32)*d**(-113)+(  -0.780049E31)*d**(-111)+(-0.198687E31)*d**(-109)+(-0.506238E30)  *d**(-107)+(-0.129023E30)*d**(-105)+(-0.328925E29)*d**(-103)+(  -0.838751E28)*d**(-101)+(-0.213927E28)*d**(-99)+(-0.54575E27)*  d**(-97)+(-0.139257E27)*d**(-95)+(-0.355421E26)*d**(-93)+( -0.907387E25)*d**(-91)+(-0.231734E25)*d**(-89)+(-0.592072E24)*  d**(-87)+(-0.151353E24)*d**(-85)+(-0.387162E23)*d**(-83)+( -0.99114E22)*d**(-81)+(-0.253967E22)*d**(-79)+(-0.651432E21)* d**(-77)+(-0.167284E21)*d**(-75)+(-0.430087E20)*d**(-73)+( -0.110709E20)*d**(-71)+(-0.285307E19)*d**(-69)+(-0.736039E18)*  d**(-67)+(-0.190053E18)*d**(-65)+(-0.491069E17)*d**(-63)+( -0.126939E17)*d**(-61)+(-0.328197E16)*d**(-59)+(-0.848547E15)*  d**(-57)+(-0.219378E15)*d**(-55)+(-0.567206E14)*d**(-53)+( -0.146722E14)*d**(-51)+(-0.379992E13)*d**(-49)+(-0.986353E12)*  d**(-47)+(-0.256936E12)*d**(-45)+(-0.672513E11)*d**(-43)+( -0.177033E11)*d**(-41)+(-0.468758E10)*d**(-39)+(-0.124734E10)*  d**(-37)+(-0.33288E9)*d**(-35)+(-0.888484E8)*d**(-33)+( -0.236515E8)*d**(-31)+(-0.62688E7)*d**(-29)+(-0.165577E7)*d**(  -27)+(-0.437892E6)*d**(-25)+(-0.116985E6)*d**(-23)+(-0.319093E5)  *d**(-21)+(-0.896241E4)*d**(-19)+(-0.260066E4)*d**(-17)+( -0.773672E3)*d**(-15)+(-0.228508E3)*d**(-13)+(-0.636251E2)*d**(  -11)+(-0.169807E2)*d**(-9)+(-0.547137E1)*d**(-7)+(-0.220605E1)*  d**(-5)+(-0.921875E0)*d**(-3)+(-0.75E0)*d**(-1) 
      Y11B = -1.0*0.666667E0*((  -0.200934E58)*d**(-199)+(-0.507423E57)*d**(-197)+(-0.128153E57)  *d**(-195)+(-0.323687E56)*d**(-193)+(-0.817645E55)*d**(-191)+(  -0.20656E55)*d**(-189)+(-0.521877E54)*d**(-187)+(-0.131866E54)*  d**(-185)+(-0.33323E53)*d**(-183)+(-0.84217E52)*d**(-181)+( -0.212865E52)*d**(-179)+(-0.538091E51)*d**(-177)+(-0.136038E51)  *d**(-175)+(-0.343969E50)*d**(-173)+(-0.869833E49)*d**(-171)+(  -0.219995E49)*d**(-169)+(-0.556484E48)*d**(-167)+(-0.140786E48)  *d**(-165)+(-0.356235E47)*d**(-163)+(-0.901545E46)*d**(-161)+(  -0.2282E46)*d**(-159)+(-0.577728E45)*d**(-157)+(-0.14629E45)*  d**(-155)+(-0.370502E44)*d**(-153)+(-0.938544E43)*d**(-151)+(  -0.237797E43)*d**(-149)+(-0.602627E42)*d**(-147)+(-0.152749E42)  *d**(-145)+(-0.387256E41)*d**(-143)+(-0.981986E40)*d**(-141)+(  -0.249056E40)*d**(-139)+(-0.631791E39)*d**(-137)+(-0.160298E39)  *d**(-135)+(-0.406783E38)*d**(-133)+(-0.103246E38)*d**(-131)+(  -0.262092E37)*d**(-129)+(-0.66544E36)*d**(-127)+(-0.168981E36)*  d**(-125)+(-0.42918E35)*d**(-123)+(-0.109024E35)*d**(-121)+( -0.277007E34)*d**(-119)+(-0.703972E33)*d**(-117)+(-0.178949E33)  *d**(-115)+(-0.455013E32)*d**(-113)+(-0.115734E32)*d**(-111)+(  -0.294481E31)*d**(-109)+(-0.749608E30)*d**(-107)+(-0.190903E30)  *d**(-105)+(-0.486421E29)*d**(-103)+(-0.124008E29)*d**(-101)+(  -0.316326E28)*d**(-99)+(-0.807377E27)*d**(-97)+(-0.206193E27)*  d**(-95)+(-0.52689E26)*d**(-93)+(-0.13471E26)*d**(-91)+( -0.344579E25)*d**(-89)+(-0.881781E24)*d**(-87)+(-0.225728E24)*  d**(-85)+(-0.578005E23)*d**(-83)+(-0.148039E23)*d**(-81)+( -0.379228E22)*d**(-79)+(-0.971639E21)*d**(-77)+(-0.249004E21)*  d**(-75)+(-0.638329E20)*d**(-73)+(-0.163713E20)*d**(-71)+( -0.420164E19)*d**(-69)+(-0.107936E19)*d**(-67)+(-0.277625E18)*  d**(-65)+(-0.715231E17)*d**(-63)+(-0.184616E17)*d**(-61)+( -0.477568E16)*d**(-59)+(-0.123824E16)*d**(-57)+(-0.321774E15)*  d**(-55)+(-0.837804E14)*d**(-53)+(-0.218443E14)*d**(-51)+( -0.569906E13)*d**(-49)+(-0.148647E13)*d**(-47)+(-0.38731E12)* d**(-45)+(-0.100773E12)*d**(-43)+(-0.261915E11)*d**(-41)+( -0.680915E10)*d**(-39)+(-0.177514E10)*d**(-37)+(-0.46566E9)* d**(-35)+(-0.123347E9)*d**(-33)+(-0.330675E8)*d**(-31)+( -0.896818E7)*d**(-29)+(-0.245097E7)*d**(-27)+(-0.670507E6)*d**(  -25)+(-0.182319E6)*d**(-23)+(-0.490448E5)*d**(-21)+(-0.130366E5)  *d**(-19)+(-0.343661E4)*d**(-17)+(-0.920063E3)*d**(-15)+( -0.268743E3)*d**(-13)+(-0.905572E2)*d**(-11)+(-0.310616E2)*d**(  -9)+(-0.860596E1)*d**(-7)+(-0.213281E1)*d**(-5)+(-0.1125E1)*  d**(-3))
      Y12B = -1.0*0.666667E0*(0.399861E58*d**(-200)+0.100973E58*d**( -198)+0.255002E57*d**(-196)+0.644053E56*d**(-194)+0.162682E56*  d**(-192)+0.41096E55*d**(-190)+0.103825E55*d**(-188)+ 0.262329E54*d**(-186)+0.662878E53*d**(-184)+0.16752E53*d**( -182)+0.423395E52*d**(-180)+0.107022E52*d**(-178)+0.270553E51*  d**(-176)+0.684043E50*d**(-174)+0.17297E50*d**(-172)+ 0.437438E49*d**(-170)+0.110643E49*d**(-168)+0.279896E48*d**( -166)+0.708172E47*d**(-164)+0.179206E47*d**(-162)+0.453567E46*  d**(-160)+0.114818E46*d**(-158)+0.290709E45*d**(-156)+ 0.736193E44*d**(-154)+0.186471E44*d**(-152)+0.47241E43*d**( -150)+0.119706E43*d**(-148)+0.30339E42*d**(-146)+0.76909E41* d**(-144)+0.195003E41*d**(-142)+0.494527E40*d**(-140)+ 0.125437E40*d**(-138)+0.318229E39*d**(-136)+0.807486E38*d**( -134)+0.204931E38*d**(-132)+0.520179E37*d**(-130)+0.13206E37* d**(-128)+0.335322E36*d**(-126)+0.851585E35*d**(-124)+ 0.216307E35*d**(-122)+0.549534E34*d**(-120)+0.13964E34*d**( -118)+0.354918E33*d**(-116)+0.902319E32*d**(-114)+0.229469E32*  d**(-112)+0.583767E31*d**(-110)+0.148568E31*d**(-108)+ 0.378269E30*d**(-106)+0.963581E29*d**(-104)+0.245587E29*d**( -102)+0.626276E28*d**(-100)+0.159801E28*d**(-98)+0.407992E27* d**(-96)+0.104226E27*d**(-94)+0.266404E26*d**(-92)+0.681282E25*  d**(-90)+0.174305E25*d**(-88)+0.446129E24*d**(-86)+0.114221E24*  d**(-84)+0.29251E23*d**(-82)+0.749241E22*d**(-80)+0.191946E22*  d**(-78)+0.491839E21*d**(-76)+0.126061E21*d**(-74)+0.323223E20*  d**(-72)+0.829222E19*d**(-70)+0.212907E19*d**(-68)+0.547253E18*  d**(-66)+0.140867E18*d**(-64)+0.363245E17*d**(-62)+0.938616E16*  d**(-60)+0.243088E16*d**(-58)+0.631025E15*d**(-56)+0.164159E15*  d**(-54)+0.427792E14*d**(-52)+0.111599E14*d**(-50)+0.291191E13*  d**(-48)+0.759299E12*d**(-46)+0.197735E12*d**(-44)+0.514212E11*  d**(-42)+0.133634E11*d**(-40)+0.347709E10*d**(-38)+0.908506E9*  d**(-36)+0.239225E9*d**(-34)+0.636817E8*d**(-32)+0.171585E8*  d**(-30)+0.467023E7*d**(-28)+0.127723E7*d**(-26)+0.348487E6*  d**(-24)+0.943133E5*d**(-22)+0.252712E5*d**(-20)+0.672542E4*  d**(-18)+0.180245E4*d**(-16)+0.508413E3*d**(-14)+0.160513E3*  d**(-12)+0.540703E2*d**(-10)+0.157474E2*d**(-8)+0.328711E1*d**(  -6)+0.84375E0*d**(-4)+0.15E1*d**(-2))
      X11C = 0.133333E1*(0.1E1+ 0.198212E56*d**(-200)+0.505522E55*d**(-198)+0.128955E55*d**( -196)+0.329022E54*d**(-194)+0.839659E53*d**(-192)+0.214326E53*  d**(-190)+0.547195E52*d**(-188)+0.139736E52*d**(-186)+ 0.356921E51*d**(-184)+0.911882E50*d**(-182)+0.233029E50*d**( -180)+0.595643E49*d**(-178)+0.15229E49*d**(-176)+0.389467E48* d**(-174)+0.996281E47*d**(-172)+0.254924E47*d**(-170)+ 0.652466E46*d**(-168)+0.167043E46*d**(-166)+0.427782E45*d**( -164)+0.109584E45*d**(-162)+0.280801E44*d**(-160)+0.719758E43*  d**(-158)+0.184549E43*d**(-156)+0.473343E42*d**(-154)+ 0.121447E42*d**(-152)+0.311703E41*d**(-150)+0.80029E40*d**( -148)+0.205546E40*d**(-146)+0.528113E39*d**(-144)+0.13574E39* d**(-142)+0.349023E38*d**(-140)+0.89778E37*d**(-138)+ 0.231026E37*d**(-136)+0.594746E36*d**(-134)+0.153174E36*d**( -132)+0.394666E35*d**(-130)+0.101735E35*d**(-128)+0.262367E34*  d**(-126)+0.676952E33*d**(-124)+0.174752E33*d**(-122)+ 0.451343E32*d**(-120)+0.116634E32*d**(-118)+0.301566E31*d**( -116)+0.780173E30*d**(-114)+0.201958E30*d**(-112)+0.523124E29*  d**(-110)+0.135592E29*d**(-108)+0.351696E28*d**(-106)+ 0.912882E27*d**(-104)+0.237134E27*d**(-102)+0.616486E26*d**( -100)+0.160405E26*d**(-98)+0.417735E25*d**(-96)+0.10889E25*d**(  -94)+0.284117E24*d**(-92)+0.742079E23*d**(-90)+0.194027E23*d**(  -88)+0.507869E22*d**(-86)+0.133086E22*d**(-84)+0.349155E21*d**(  -82)+0.917099E20*d**(-80)+0.241176E20*d**(-78)+0.635001E19*d**(  -76)+0.167393E19*d**(-74)+0.441791E18*d**(-72)+0.116737E18*d**(  -70)+0.308824E17*d**(-68)+0.817937E16*d**(-66)+0.216891E16*d**(  -64)+0.575832E15*d**(-62)+0.153081E15*d**(-60)+0.40756E14*d**(  -58)+0.108696E14*d**(-56)+0.290504E13*d**(-54)+0.778456E12*d**(  -52)+0.209296E12*d**(-50)+0.565078E11*d**(-48)+0.153366E11*d**(  -46)+0.418903E10*d**(-44)+0.115282E10*d**(-42)+0.319957E9*d**(  -40)+0.896121E8*d**(-38)+0.25326E8*d**(-36)+0.721597E7*d**(-34)  +0.206862E7*d**(-32)+0.594736E6*d**(-30)+0.170712E6*d**(-28)+  0.48636E5*d**(-26)+0.13656E5*d**(-24)+0.375E4*d**(-22)+ 0.1002E4*d**(-20)+0.263E3*d**(-18)+0.72E2*d**(-16)+0.24E2*d**(  -14)+0.11E2*d**(-12)+0.6E1*d**(-10)+0.3E1*d**(-8)+d**(-6))
      X12C = 0.133333E1*((-0.100109E56)*d**(-199)+(-0.255348E55)*d**(-197)+(  -0.651444E54)*d**(-195)+(-0.166231E54)*d**(-193)+(-0.424267E53)  *d**(-191)+(-0.108308E53)*d**(-189)+(-0.276551E52)*d**(-187)+(  -0.706297E51)*d**(-185)+(-0.180426E51)*d**(-183)+(-0.461013E50)  *d**(-181)+(-0.117823E50)*d**(-179)+(-0.3012E49)*d**(-177)+(  -0.77017E48)*d**(-175)+(-0.196983E48)*d**(-173)+(-0.503947E47)*  d**(-171)+(-0.128961E47)*d**(-169)+(-0.330102E46)*d**(-167)+(  -0.845202E45)*d**(-165)+(-0.21647E45)*d**(-163)+(-0.554578E44)*  d**(-161)+(-0.142121E44)*d**(-159)+(-0.364327E43)*d**(-157)+(  -0.934245E42)*d**(-155)+(-0.239648E42)*d**(-153)+(-0.614939E41)  *d**(-151)+(-0.157849E41)*d**(-149)+(-0.405327E40)*d**(-147)+(  -0.104119E40)*d**(-145)+(-0.267559E39)*d**(-143)+(-0.687826E38)  *d**(-141)+(-0.176894E38)*d**(-139)+(-0.455122E37)*d**(-137)+(  -0.117146E37)*d**(-135)+(-0.301663E36)*d**(-133)+(-0.777166E35)  *d**(-131)+(-0.200314E35)*d**(-129)+(-0.516557E34)*d**(-127)+(  -0.133273E34)*d**(-125)+(-0.344027E33)*d**(-123)+(-0.888532E32)  *d**(-121)+(-0.22961E32)*d**(-119)+(-0.593681E31)*d**(-117)+(  -0.153591E31)*d**(-115)+(-0.397591E30)*d**(-113)+(-0.102985E30)  *d**(-111)+(-0.266918E29)*d**(-109)+(-0.692246E28)*d**(-107)+(  -0.17965E28)*d**(-105)+(-0.466537E27)*d**(-103)+(-0.121239E27)*  d**(-101)+(-0.315286E26)*d**(-99)+(-0.820506E25)*d**(-97)+( -0.213689E25)*d**(-95)+(-0.556953E24)*d**(-93)+(-0.145279E24)*  d**(-91)+(-0.379273E23)*d**(-89)+(-0.991024E22)*d**(-87)+( -0.259193E22)*d**(-85)+(-0.678573E21)*d**(-83)+(-0.177844E21)*  d**(-81)+(-0.466649E20)*d**(-79)+(-0.122602E20)*d**(-77)+( -0.322563E19)*d**(-75)+(-0.849974E18)*d**(-73)+(-0.224357E18)*  d**(-71)+(-0.593327E17)*d**(-69)+(-0.157235E17)*d**(-67)+( -0.417623E16)*d**(-65)+(-0.111194E16)*d**(-63)+(-0.296828E15)*  d**(-61)+(-0.794536E14)*d**(-59)+(-0.213272E14)*d**(-57)+( -0.574068E13)*d**(-55)+(-0.154938E13)*d**(-53)+(-0.419208E12)*  d**(-51)+(-0.113666E12)*d**(-49)+(-0.308729E11)*d**(-47)+( -0.839524E10)*d**(-45)+(-0.228432E10)*d**(-43)+(-0.621627E9)* d**(-41)+(-0.169137E9)*d**(-39)+(-0.460247E8)*d**(-37)+( -0.125397E8)*d**(-35)+(-0.342984E7)*d**(-33)+(-0.94632E6)*d**(  -31)+(-0.265344E6)*d**(-29)+(-0.76351E5)*d**(-27)+(-0.2277E5)*  d**(-25)+(-0.708E4)*d**(-23)+(-0.2289E4)*d**(-21)+(-0.759E3)*  d**(-19)+(-0.252E3)*d**(-17)+(-0.81E2)*d**(-15)+(-0.24E2)*d**(  -13)+(-0.6E1)*d**(-11)+(-0.1E1)*d**(-9)+(-0.1E1)*d**(-3))
      Y11C = 0.133333E1*(0.1E1+0.31832E58*d**(-200)+0.803761E57*d**(-198)+ 0.202972E57*d**(-196)+0.512617E56*d**(-194)+0.129479E56*d**( -192)+0.32708E55*d**(-190)+0.826341E54*d**(-188)+0.208793E54*  d**(-186)+0.527625E53*d**(-184)+0.133348E53*d**(-182)+ 0.337056E52*d**(-180)+0.852058E51*d**(-178)+0.215422E51*d**( -176)+0.544711E50*d**(-174)+0.137751E50*d**(-172)+0.348401E49*  d**(-170)+0.881289E48*d**(-168)+0.222952E48*d**(-166)+ 0.564106E47*d**(-164)+0.142747E47*d**(-162)+0.361267E46*d**( -160)+0.914425E45*d**(-158)+0.231488E45*d**(-156)+0.586099E44*  d**(-154)+0.148415E44*d**(-152)+0.375883E43*d**(-150)+ 0.952134E42*d**(-148)+0.241223E42*d**(-146)+0.611249E41*d**( -144)+0.154918E41*d**(-142)+0.392714E40*d**(-140)+0.995736E39*  d**(-138)+0.25253E39*d**(-136)+0.6406E38*d**(-134)+0.162544E38*  d**(-132)+0.412546E37*d**(-130)+0.104735E37*d**(-128)+ 0.265971E36*d**(-126)+0.675617E35*d**(-124)+0.171669E35*d**( -122)+0.436323E34*d**(-120)+0.11093E34*d**(-118)+0.282102E33* d**(-116)+0.7176E32*d**(-114)+0.182588E32*d**(-112)+ 0.464695E31*d**(-110)+0.118296E31*d**(-108)+0.301215E30*d**( -106)+0.767159E29*d**(-104)+0.195435E29*d**(-102)+0.498005E28*  d**(-100)+0.126938E28*d**(-98)+0.323664E27*d**(-96)+ 0.825587E26*d**(-94)+0.21068E26*d**(-92)+0.537907E25*d**(-90)+  0.137418E25*d**(-88)+0.351293E24*d**(-86)+0.898695E23*d**(-84)+  0.230089E23*d**(-82)+0.589575E22*d**(-80)+0.151199E22*d**(-78)+  0.38808E21*d**(-76)+0.996868E20*d**(-74)+0.256254E20*d**(-72)+  0.65914E19*d**(-70)+0.169635E19*d**(-68)+0.43675E18*d**(-66)+  0.112484E18*d**(-64)+0.289781E17*d**(-62)+0.746745E16*d**(-60)+  0.192511E16*d**(-58)+0.496627E15*d**(-56)+0.128256E15*d**(-54)+  0.33178E14*d**(-52)+0.860273E13*d**(-50)+0.223736E13*d**(-48)+  0.583953E12*d**(-46)+0.152984E12*d**(-44)+0.402164E11*d**(-42)+  0.105988E11*d**(-40)+0.279642E10*d**(-38)+0.737501E9*d**(-36)+  0.194181E9*d**(-34)+0.510319E8*d**(-32)+0.134064E8*d**(-30)+  0.353338E7*d**(-28)+0.939245E6*d**(-26)+0.25312E6*d**(-24)+ 0.693277E5*d**(-22)+0.192754E5*d**(-20)+0.541718E4*d**(-18)+ 0.152169E4*d**(-16)+0.41662E3*d**(-14)+0.10984E3*d**(-12)+ 0.31235E2*d**(-10)+0.116748E2*d**(-8)+0.442188E1*d**(-6)+ 0.75E0*d**(-4))
      Y12C = 0.133333E1*(0.398429E57*d**(-199)+0.100606E57*  d**(-197)+0.25407E56*d**(-195)+0.641715E55*d**(-193)+ 0.162103E55*d**(-191)+0.409541E54*d**(-189)+0.103482E54*d**( -187)+0.261513E53*d**(-185)+0.66097E52*d**(-183)+0.167081E52* d**(-181)+0.422406E51*d**(-179)+0.106804E51*d**(-177)+ 0.270083E50*d**(-175)+0.683054E49*d**(-173)+0.172766E49*d**( -171)+0.437025E48*d**(-169)+0.110559E48*d**(-167)+0.279717E47*  d**(-165)+0.707747E46*d**(-163)+0.17909E46*d**(-161)+ 0.45321E45*d**(-159)+0.1147E45*d**(-157)+0.290309E44*d**(-155)+  0.734853E43*d**(-153)+0.186031E43*d**(-151)+0.471004E42*d**(  -149)+0.119268E42*d**(-147)+0.302064E41*d**(-145)+0.765168E40*  d**(-143)+0.193871E40*d**(-141)+0.491342E39*d**(-139)+ 0.12456E39*d**(-137)+0.315877E38*d**(-135)+0.80133E37*d**(-133)  +0.203362E37*d**(-131)+0.516302E36*d**(-129)+0.131135E36*d**(  -127)+0.333204E35*d**(-125)+0.84699E34*d**(-123)+0.215383E34*  d**(-121)+0.547894E33*d**(-119)+0.139415E33*d**(-117)+ 0.354835E32*d**(-115)+0.903271E31*d**(-113)+0.229962E31*d**( -111)+0.585475E30*d**(-109)+0.149057E30*d**(-107)+0.379459E29*  d**(-105)+0.965915E28*d**(-103)+0.245854E28*d**(-101)+ 0.625749E27*d**(-99)+0.159274E27*d**(-97)+0.405476E26*d**(-95)+  0.103262E26*d**(-93)+0.263121E25*d**(-91)+0.670992E24*d**(-89)+  0.171288E24*d**(-87)+0.437811E23*d**(-85)+0.112067E23*d**(-83)+  0.287311E22*d**(-81)+0.737781E21*d**(-79)+0.189745E21*d**(-77)+  0.488646E20*d**(-75)+0.125969E20*d**(-73)+0.324932E19*d**(-71)+  0.838222E18*d**(-69)+0.216134E18*d**(-67)+0.556741E17*d**(-65)+  0.143203E17*d**(-63)+0.367716E16*d**(-61)+0.942657E15*d**(-59)+  0.241376E15*d**(-57)+0.61802E14*d**(-55)+0.158497E14*d**(-53)+  0.408075E13*d**(-51)+0.105744E13*d**(-49)+0.276381E12*d**(-47)+  0.729322E11*d**(-45)+0.194114E11*d**(-43)+0.519358E10*d**(-41)+  0.13893E10*d**(-39)+0.369151E9*d**(-37)+0.968268E8*d**(-35)+  0.249707E8*d**(-33)+0.633664E7*d**(-31)+0.159675E7*d**(-29)+  0.407757E6*d**(-27)+0.108519E6*d**(-25)+0.306987E5*d**(-23)+  0.918528E4*d**(-21)+0.283133E4*d**(-19)+0.86237E3*d**(-17)+ 0.239751E3*d**(-15)+0.519789E2*d**(-13)+0.684865E1*d**(-11)+ 0.145142E1*d**(-9)+0.144141E1*d**(-7)+0.5625E0*d**(-5)+0.5E0*  d**(-3))
    else:     # order 100
      X11A = 0.1E1+0.3226E30*d**(-100)+0.806805E29*d**(-98)+0.201781E29* d**(-96)+0.504663E28*d**(-94)+0.12622E28*d**(-92)+0.31569E27*  d**(-90)+0.789587E26*d**(-88)+0.197489E26*d**(-86)+0.493961E25*   d**(-84)+0.123551E25*d**(-82)+0.309032E24*d**(-80)+0.772979E23*   d**(-78)+0.193348E23*d**(-76)+0.483638E22*d**(-74)+0.120981E22*   d**(-72)+0.302642E21*d**(-70)+0.757127E20*d**(-68)+0.189426E20*   d**(-66)+0.473966E19*d**(-64)+0.118604E19*d**(-62)+0.296821E18*   d**(-60)+0.742915E17*d**(-58)+0.185963E17*d**(-56)+0.465529E16*   d**(-54)+0.116543E16*d**(-52)+0.291765E15*d**(-50)+0.730412E14*   d**(-48)+0.182845E14*d**(-46)+0.457705E13*d**(-44)+0.114578E13*   d**(-42)+0.286864E12*d**(-40)+0.71845E11*d**(-38)+0.180034E11*   d**(-36)+0.45149E10*d**(-34)+0.11333E10*d**(-32)+0.284734E9*   d**(-30)+0.715871E8*d**(-28)+0.180017E8*d**(-26)+0.452419E7*   d**(-24)+0.113542E7*d**(-22)+0.284461E6*d**(-20)+0.712667E5*   d**(-18)+0.179606E5*d**(-16)+0.459856E4*d**(-14)+0.120073E4*   d**(-12)+0.312669E3*d**(-10)+0.774258E2*d**(-8)+0.187031E2*d**(   -6)+0.58125E1*d**(-4)+0.225E1*d**(-2)
      X12A = (-0.161331E30)*d**(-99)+(   -0.403466E29)*d**(-97)+(-0.100903E29)*d**(-95)+(-0.252351E28)*   d**(-93)+(-0.631125E27)*d**(-91)+(-0.157847E27)*d**(-89)+( -0.394792E26)*d**(-87)+(-0.987446E25)*d**(-85)+(-0.246987E25)*   d**(-83)+(-0.617804E24)*d**(-81)+(-0.154542E24)*d**(-79)+( -0.386596E23)*d**(-77)+(-0.967135E22)*d**(-75)+(-0.241954E22)*   d**(-73)+(-0.605333E21)*d**(-71)+(-0.151449E21)*d**(-69)+( -0.37892E20)*d**(-67)+(-0.948055E19)*d**(-65)+(-0.237204E19)*  d**(-63)+(-0.59349E18)*d**(-61)+(-0.148494E18)*d**(-59)+( -0.371551E17)*d**(-57)+(-0.929719E16)*d**(-55)+(-0.232663E16)*   d**(-53)+(-0.582331E15)*d**(-51)+(-0.145782E15)*d**(-49)+( -0.365052E14)*d**(-47)+(-0.9144E13)*d**(-45)+(-0.229114E13)* d**(-43)+(-0.574221E12)*d**(-41)+(-0.143938E12)*d**(-39)+( -0.360806E11)*d**(-37)+(-0.904289E10)*d**(-35)+(-0.226584E10)*   d**(-33)+(-0.56761E9)*d**(-31)+(-0.142196E9)*d**(-29)+( -0.356445E8)*d**(-27)+(-0.894878E7)*d**(-25)+(-0.225269E7)*d**(   -23)+(-0.569168E6)*d**(-21)+(-0.144329E6)*d**(-19)+(-0.366335E5)   *d**(-17)+(-0.925019E4)*d**(-15)+(-0.231026E4)*d**(-13)+( -0.575416E3)*d**(-11)+(-0.148662E3)*d**(-9)+(-0.416484E2)*d**(   -7)+(-0.120938E2)*d**(-5)+(-0.2375E1)*d**(-3)+(-0.15E1)*d**(-1)
      Y11A = 0.1E1+0.423581E28*d**(-100)+0.108048E28*d**(-98)+0.275671E27*   d**(-96)+0.7035E26*d**(-94)+0.179576E26*d**(-92)+0.458531E25*   d**(-90)+0.117126E25*d**(-88)+0.299329E24*d**(-86)+0.76542E23*   d**(-84)+0.195868E23*d**(-82)+0.501647E22*d**(-80)+0.128605E22*   d**(-78)+0.330059E21*d**(-76)+0.848074E20*d**(-74)+0.218173E20*   d**(-72)+0.561935E19*d**(-70)+0.144897E19*d**(-68)+0.373988E18*   d**(-66)+0.966053E17*d**(-64)+0.249681E17*d**(-62)+0.645508E16*   d**(-60)+0.166899E16*d**(-58)+0.431497E15*d**(-56)+0.111554E15*   d**(-54)+0.288461E14*d**(-52)+0.746499E13*d**(-50)+0.193511E13*   d**(-48)+0.503082E12*d**(-46)+0.131341E12*d**(-44)+0.344737E11*   d**(-42)+0.910203E10*d**(-40)+0.241644E10*d**(-38)+0.644077E9*   d**(-36)+0.171927E9*d**(-34)+0.458319E8*d**(-32)+0.121748E8*   d**(-30)+0.322191E7*d**(-28)+0.85194E6*d**(-26)+0.226612E6*d**(   -24)+0.611923E5*d**(-22)+0.169127E5*d**(-20)+0.480976E4*d**(   -18)+0.140936E4*d**(-16)+0.419821E3*d**(-14)+0.121272E3*d**(   -12)+0.321186E2*d**(-10)+0.869777E1*d**(-8)+0.359985E1*d**(-6)+   0.181641E1*d**(-4)+0.5625E0*d**(-2)
      Y12A = (-0.213927E28)*d**(-99)+(   -0.54575E27)*d**(-97)+(-0.139257E27)*d**(-95)+(-0.355421E26)*   d**(-93)+(-0.907387E25)*d**(-91)+(-0.231734E25)*d**(-89)+( -0.592072E24)*d**(-87)+(-0.151353E24)*d**(-85)+(-0.387162E23)*   d**(-83)+(-0.99114E22)*d**(-81)+(-0.253967E22)*d**(-79)+( -0.651432E21)*d**(-77)+(-0.167284E21)*d**(-75)+(-0.430087E20)*   d**(-73)+(-0.110709E20)*d**(-71)+(-0.285307E19)*d**(-69)+( -0.736039E18)*d**(-67)+(-0.190053E18)*d**(-65)+(-0.491069E17)*   d**(-63)+(-0.126939E17)*d**(-61)+(-0.328197E16)*d**(-59)+( -0.848547E15)*d**(-57)+(-0.219378E15)*d**(-55)+(-0.567206E14)*   d**(-53)+(-0.146722E14)*d**(-51)+(-0.379992E13)*d**(-49)+( -0.986353E12)*d**(-47)+(-0.256936E12)*d**(-45)+(-0.672513E11)*   d**(-43)+(-0.177033E11)*d**(-41)+(-0.468758E10)*d**(-39)+( -0.124734E10)*d**(-37)+(-0.33288E9)*d**(-35)+(-0.888484E8)*d**(   -33)+(-0.236515E8)*d**(-31)+(-0.62688E7)*d**(-29)+(-0.165577E7)   *d**(-27)+(-0.437892E6)*d**(-25)+(-0.116985E6)*d**(-23)+( -0.319093E5)*d**(-21)+(-0.896241E4)*d**(-19)+(-0.260066E4)*d**(   -17)+(-0.773672E3)*d**(-15)+(-0.228508E3)*d**(-13)+(-0.636251E2)   *d**(-11)+(-0.169807E2)*d**(-9)+(-0.547137E1)*d**(-7)+( -0.220605E1)*d**(-5)+(-0.921875E0)*d**(-3)+(-0.75E0)*d**(-1)
      Y11B = -1.0*0.666667E0*((-0.316326E28)*d**(-99)+(-0.807377E27)*d**(-97)+(   -0.206193E27)*d**(-95)+(-0.52689E26)*d**(-93)+(-0.13471E26)*   d**(-91)+(-0.344579E25)*d**(-89)+(-0.881781E24)*d**(-87)+( -0.225728E24)*d**(-85)+(-0.578005E23)*d**(-83)+(-0.148039E23)*   d**(-81)+(-0.379228E22)*d**(-79)+(-0.971639E21)*d**(-77)+( -0.249004E21)*d**(-75)+(-0.638329E20)*d**(-73)+(-0.163713E20)*   d**(-71)+(-0.420164E19)*d**(-69)+(-0.107936E19)*d**(-67)+( -0.277625E18)*d**(-65)+(-0.715231E17)*d**(-63)+(-0.184616E17)*   d**(-61)+(-0.477568E16)*d**(-59)+(-0.123824E16)*d**(-57)+( -0.321774E15)*d**(-55)+(-0.837804E14)*d**(-53)+(-0.218443E14)*   d**(-51)+(-0.569906E13)*d**(-49)+(-0.148647E13)*d**(-47)+( -0.38731E12)*d**(-45)+(-0.100773E12)*d**(-43)+(-0.261915E11)*  d**(-41)+(-0.680915E10)*d**(-39)+(-0.177514E10)*d**(-37)+( -0.46566E9)*d**(-35)+(-0.123347E9)*d**(-33)+(-0.330675E8)*d**(   -31)+(-0.896818E7)*d**(-29)+(-0.245097E7)*d**(-27)+(-0.670507E6)   *d**(-25)+(-0.182319E6)*d**(-23)+(-0.490448E5)*d**(-21)+( -0.130366E5)*d**(-19)+(-0.343661E4)*d**(-17)+(-0.920063E3)*d**(   -15)+(-0.268743E3)*d**(-13)+(-0.905572E2)*d**(-11)+(-0.310616E2)   *d**(-9)+(-0.860596E1)*d**(-7)+(-0.213281E1)*d**(-5)+( -0.1125E1)*d**(-3))
      Y12B = -1.0*0.666667E0*(0.626276E28*d**(-100)+ 0.159801E28*d**(-98)+0.407992E27*d**(-96)+0.104226E27*d**(-94)+   0.266404E26*d**(-92)+0.681282E25*d**(-90)+0.174305E25*d**(-88)+   0.446129E24*d**(-86)+0.114221E24*d**(-84)+0.29251E23*d**(-82)+   0.749241E22*d**(-80)+0.191946E22*d**(-78)+0.491839E21*d**(-76)+   0.126061E21*d**(-74)+0.323223E20*d**(-72)+0.829222E19*d**(-70)+   0.212907E19*d**(-68)+0.547253E18*d**(-66)+0.140867E18*d**(-64)+   0.363245E17*d**(-62)+0.938616E16*d**(-60)+0.243088E16*d**(-58)+   0.631025E15*d**(-56)+0.164159E15*d**(-54)+0.427792E14*d**(-52)+   0.111599E14*d**(-50)+0.291191E13*d**(-48)+0.759299E12*d**(-46)+   0.197735E12*d**(-44)+0.514212E11*d**(-42)+0.133634E11*d**(-40)+   0.347709E10*d**(-38)+0.908506E9*d**(-36)+0.239225E9*d**(-34)+   0.636817E8*d**(-32)+0.171585E8*d**(-30)+0.467023E7*d**(-28)+   0.127723E7*d**(-26)+0.348487E6*d**(-24)+0.943133E5*d**(-22)+   0.252712E5*d**(-20)+0.672542E4*d**(-18)+0.180245E4*d**(-16)+   0.508413E3*d**(-14)+0.160513E3*d**(-12)+0.540703E2*d**(-10)+   0.157474E2*d**(-8)+0.328711E1*d**(-6)+0.84375E0*d**(-4)+ 0.15E1*d**(-2))
      X11C = 0.133333E1*(0.1E1+0.616486E26*d**(-100)+ 0.160405E26*d**(-98)+0.417735E25*d**(-96)+0.10889E25*d**(-94)+   0.284117E24*d**(-92)+0.742079E23*d**(-90)+0.194027E23*d**(-88)+   0.507869E22*d**(-86)+0.133086E22*d**(-84)+0.349155E21*d**(-82)+   0.917099E20*d**(-80)+0.241176E20*d**(-78)+0.635001E19*d**(-76)+   0.167393E19*d**(-74)+0.441791E18*d**(-72)+0.116737E18*d**(-70)+   0.308824E17*d**(-68)+0.817937E16*d**(-66)+0.216891E16*d**(-64)+   0.575832E15*d**(-62)+0.153081E15*d**(-60)+0.40756E14*d**(-58)+   0.108696E14*d**(-56)+0.290504E13*d**(-54)+0.778456E12*d**(-52)+   0.209296E12*d**(-50)+0.565078E11*d**(-48)+0.153366E11*d**(-46)+   0.418903E10*d**(-44)+0.115282E10*d**(-42)+0.319957E9*d**(-40)+   0.896121E8*d**(-38)+0.25326E8*d**(-36)+0.721597E7*d**(-34)+  0.206862E7*d**(-32)+0.594736E6*d**(-30)+0.170712E6*d**(-28)+  0.48636E5*d**(-26)+0.13656E5*d**(-24)+0.375E4*d**(-22)+ 0.1002E4*d**(-20)+0.263E3*d**(-18)+0.72E2*d**(-16)+0.24E2*d**(   -14)+0.11E2*d**(-12)+0.6E1*d**(-10)+0.3E1*d**(-8)+d**(-6))
      X12C = 0.133333E1*((-0.315286E26)*d**(-99)+(-0.820506E25)*d**(-97)+(   -0.213689E25)*d**(-95)+(-0.556953E24)*d**(-93)+(-0.145279E24)*   d**(-91)+(-0.379273E23)*d**(-89)+(-0.991024E22)*d**(-87)+( -0.259193E22)*d**(-85)+(-0.678573E21)*d**(-83)+(-0.177844E21)*   d**(-81)+(-0.466649E20)*d**(-79)+(-0.122602E20)*d**(-77)+( -0.322563E19)*d**(-75)+(-0.849974E18)*d**(-73)+(-0.224357E18)*   d**(-71)+(-0.593327E17)*d**(-69)+(-0.157235E17)*d**(-67)+( -0.417623E16)*d**(-65)+(-0.111194E16)*d**(-63)+(-0.296828E15)*   d**(-61)+(-0.794536E14)*d**(-59)+(-0.213272E14)*d**(-57)+( -0.574068E13)*d**(-55)+(-0.154938E13)*d**(-53)+(-0.419208E12)*   d**(-51)+(-0.113666E12)*d**(-49)+(-0.308729E11)*d**(-47)+( -0.839524E10)*d**(-45)+(-0.228432E10)*d**(-43)+(-0.621627E9)*  d**(-41)+(-0.169137E9)*d**(-39)+(-0.460247E8)*d**(-37)+( -0.125397E8)*d**(-35)+(-0.342984E7)*d**(-33)+(-0.94632E6)*d**(   -31)+(-0.265344E6)*d**(-29)+(-0.76351E5)*d**(-27)+(-0.2277E5)*   d**(-25)+(-0.708E4)*d**(-23)+(-0.2289E4)*d**(-21)+(-0.759E3)*   d**(-19)+(-0.252E3)*d**(-17)+(-0.81E2)*d**(-15)+(-0.24E2)*d**(   -13)+(-0.6E1)*d**(-11)+(-0.1E1)*d**(-9)+(-0.1E1)*d**(-3))
      Y11C = 0.133333E1*(0.1E1+0.498005E28*d**(-100)+0.126938E28*d**(-98)+  0.323664E27*d**(-96)+0.825587E26*d**(-94)+0.21068E26*d**(-92)+   0.537907E25*d**(-90)+0.137418E25*d**(-88)+0.351293E24*d**(-86)+   0.898695E23*d**(-84)+0.230089E23*d**(-82)+0.589575E22*d**(-80)+   0.151199E22*d**(-78)+0.38808E21*d**(-76)+0.996868E20*d**(-74)+   0.256254E20*d**(-72)+0.65914E19*d**(-70)+0.169635E19*d**(-68)+   0.43675E18*d**(-66)+0.112484E18*d**(-64)+0.289781E17*d**(-62)+   0.746745E16*d**(-60)+0.192511E16*d**(-58)+0.496627E15*d**(-56)+   0.128256E15*d**(-54)+0.33178E14*d**(-52)+0.860273E13*d**(-50)+   0.223736E13*d**(-48)+0.583953E12*d**(-46)+0.152984E12*d**(-44)+   0.402164E11*d**(-42)+0.105988E11*d**(-40)+0.279642E10*d**(-38)+   0.737501E9*d**(-36)+0.194181E9*d**(-34)+0.510319E8*d**(-32)+   0.134064E8*d**(-30)+0.353338E7*d**(-28)+0.939245E6*d**(-26)+   0.25312E6*d**(-24)+0.693277E5*d**(-22)+0.192754E5*d**(-20)+  0.541718E4*d**(-18)+0.152169E4*d**(-16)+0.41662E3*d**(-14)+ 0.10984E3*d**(-12)+0.31235E2*d**(-10)+0.116748E2*d**(-8)+ 0.442188E1*d**(-6)+0.75E0*d**(-4))
      Y12C = 0.133333E1*(0.625749E27* d**(-99)+0.159274E27*d**(-97)+0.405476E26*d**(-95)+0.103262E26*   d**(-93)+0.263121E25*d**(-91)+0.670992E24*d**(-89)+0.171288E24*   d**(-87)+0.437811E23*d**(-85)+0.112067E23*d**(-83)+0.287311E22*   d**(-81)+0.737781E21*d**(-79)+0.189745E21*d**(-77)+0.488646E20*   d**(-75)+0.125969E20*d**(-73)+0.324932E19*d**(-71)+0.838222E18*   d**(-69)+0.216134E18*d**(-67)+0.556741E17*d**(-65)+0.143203E17*   d**(-63)+0.367716E16*d**(-61)+0.942657E15*d**(-59)+0.241376E15*   d**(-57)+0.61802E14*d**(-55)+0.158497E14*d**(-53)+0.408075E13*   d**(-51)+0.105744E13*d**(-49)+0.276381E12*d**(-47)+0.729322E11*   d**(-45)+0.194114E11*d**(-43)+0.519358E10*d**(-41)+0.13893E10*   d**(-39)+0.369151E9*d**(-37)+0.968268E8*d**(-35)+0.249707E8*   d**(-33)+0.633664E7*d**(-31)+0.159675E7*d**(-29)+0.407757E6*   d**(-27)+0.108519E6*d**(-25)+0.306987E5*d**(-23)+0.918528E4*   d**(-21)+0.283133E4*d**(-19)+0.86237E3*d**(-17)+0.239751E3*d**(   -15)+0.519789E2*d**(-13)+0.684865E1*d**(-11)+0.145142E1*d**(-9)   +0.144141E1*d**(-7)+0.5625E0*d**(-5)+0.5E0*d**(-3))
    
    ################################################
    #
    #   The coeffs, Y11B. Y12B have been negated 
    #   Owing to the traspose of vortMat taken
    #   in the matlab script JO_Resist.m
    #
    ################################################
    
    Xa = np.array([[X11A, X12A], [X12A, X11A]])
    Ya = np.array([[Y11A, Y12A], [Y12A, Y11A]])
    Yb = np.array([[Y11B, -Y12B], [Y12B, -Y11B]])
    Xc = np.array([[X11C, X12C], [X12C, X11C]])
    Yc = np.array([[Y11C, Y12C], [Y12C, Y11C]])
    
    return Xa, Ya, Yb, Xc, Yc

  def Resist(self, r_i, r_j, eta, a, L=None):
    ''' 
    % AT_Resist computes the near-field lubrication resistance matrix for a pair of
    % identical spheres from the scalars in Adam Townsend's paper and
    % Mathmatica code.
    '''
    R_i = r_i
    R_j = r_j
    r = R_j-R_i
    #print r
    self.project_to_periodic_image(r, L)
    r = (1./a)*r
    r_norm = np.linalg.norm(r)
    #print r
    r_hat = r/r_norm
    #################################### BIG OL HACK
    r_norm = max(r_norm,2.00011)
    
    ################################################
    
    AT_cutoff = (2+0.006-1e-8);
    WS_cutoff = (2+0.1+1e-8);

    if r_norm <= AT_cutoff:
      Xa, Ya, Yb, Xc, Yc = self.AT_Resist(r_norm)
      inv=False
    elif r_norm <= WS_cutoff:
      Xa, Ya, Yb, Xc, Yc = self.WS_Resist(r_norm)
      inv=True
    else:
      Xa, Ya, Yb, Xc, Yc = self.JO_Resist(r_norm,1)#self.JO_Resist_interp(r_norm) # (the interp is slower (using cubic) and I don't knw why)
      inv=False
    
    squeezeMat = np.outer(r_hat, r_hat)
    shearMat = np.eye(3) - squeezeMat
    vortMat = np.array([[0.0,    r_hat[2], -r_hat[1]],
                        [-r_hat[2], 0.0,    r_hat[0]],
                        [r_hat[1], -r_hat[0], 0.0]])
    
    if inv:
      A_factor = 1.0 / (6*np.pi*eta*a)
      B_factor = 1.0 / (6*np.pi*eta*a**2)
      C_factor = 1.0 / (6*np.pi*eta*a**3)
    else:
      A_factor = (6*np.pi*eta*a)
      B_factor = (6*np.pi*eta*a**2)
      C_factor = (6*np.pi*eta*a**3)
    
    A = A_factor*(np.kron(Xa, squeezeMat) + np.kron(Ya, shearMat))
    B = B_factor*np.kron(Yb, vortMat)
    C = C_factor*(np.kron(Xc, squeezeMat) + np.kron(Yc, shearMat))
    
    P = np.kron(np.array([[1., 0., 0., 0.],[0., 0., 1., 0.],[0., 1., 0., 0.],[0., 0., 0., 1.]]), np.eye(3))
    ResistanceMix = np.block([[A, B],[B.T, C]])
    Resistance = np.dot(P,np.dot(ResistanceMix,P))
    
    if inv:
      Resistance = np.linalg.pinv(Resistance)
    
    return Resistance
  
  def Resist_MB_old(self, r_i, r_j, eta, a, inv=False,L=None):
    ''' 
    % Multi Blob resistance or mobility
    '''
    R_i = r_i
    R_j = r_j
    r = R_j-R_i
    r = self.project_to_periodic_image(r, L)
    r *= (1./a)
    r_norm = np.linalg.norm(r)
    r_hat = r/r_norm

    Xa, Ya, Yb, Xc, Yc = self.MB_Resist(r_norm)
 
    squeezeMat = np.outer(r_hat, r_hat)
    shearMat = np.eye(3) - squeezeMat
    vortMat = np.array([[0.0,    r_hat[2], -r_hat[1]],
                        [-r_hat[2], 0.0,    r_hat[0]],
                        [r_hat[1], -r_hat[0], 0.0]])
    
    A_factor = 1.0 / (6*np.pi*eta*a)
    B_factor = 1.0 / (6*np.pi*eta*a**2)
    C_factor = 1.0 / (6*np.pi*eta*a**3)
    
    A = A_factor*(np.kron(Xa, squeezeMat) + np.kron(Ya, shearMat))
    B = B_factor*np.kron(Yb, vortMat)
    C = C_factor*(np.kron(Xc, squeezeMat) + np.kron(Yc, shearMat))
    
    P = np.kron(np.array([[1., 0., 0., 0.],[0., 0., 1., 0.],[0., 1., 0., 0.],[0., 0., 0., 1.]]), np.eye(3))
    ResistanceMix = np.block([[A, B],[B.T, C]])
    Resistance = np.dot(P,np.dot(ResistanceMix,P))
    
    if inv:
      Resistance = np.linalg.pinv(Resistance)
    
    return Resistance
  
  def Resist_MB(self, r_i, r_j, eta, a, inv=False, L=None):
    ''' 
    % Multi Blob resistance or mobility
    '''
    R_i = r_i
    R_j = r_j
    r = R_j-R_i
    r = self.project_to_periodic_image(r, L)
    r *= (1./a)
    r_norm = np.linalg.norm(r)
    r_hat = r/r_norm
    
    #################################### BIG OL HACK
    r_norm = max(r_norm,2.00011)
    
    ################################################

    Xa, Ya, Yb, Xc, Yc = self.MB_Resist(r_norm)
 
    squeezeMat = np.outer(r_hat, r_hat)
    shearMat = np.eye(3) - squeezeMat
    vortMat = np.array([[0.0,    r_hat[2], -r_hat[1]],
                        [-r_hat[2], 0.0,    r_hat[0]],
                        [r_hat[1], -r_hat[0], 0.0]])
    
    A_factor = (6*np.pi*eta*a)
    B_factor = (6*np.pi*eta*a**2)
    C_factor = (6*np.pi*eta*a**3)
    
    A = A_factor*(np.kron(Xa, squeezeMat) + np.kron(Ya, shearMat))
    B = B_factor*np.kron(Yb, vortMat)
    C = C_factor*(np.kron(Xc, squeezeMat) + np.kron(Yc, shearMat))
    
    P = np.kron(np.array([[1., 0., 0., 0.],[0., 0., 1., 0.],[0., 1., 0., 0.],[0., 0., 0., 1.]]), np.eye(3))
    ResistanceMix = np.block([[A, B],[B.T, C]])
    Resistance = np.dot(P,np.dot(ResistanceMix,P))
    
    if inv:
      Resistance = np.linalg.pinv(Resistance)
    
    return Resistance
  
  def Pair_MB_numba(self, FT, r_i, r_j, eta, a, wall=True, L=None):
    ''' 
    % numba pair mobility mult
    '''
    pair_r_vecs = np.stack((r_i, r_j), axis=0)
    P = np.kron(np.array([[1., 0., 0., 0.],[0., 0., 1., 0.],[0., 1., 0., 0.],[0., 0., 0., 1.]]), np.eye(3))
    FT_perm = np.dot(P,FT)
    
    F = FT_perm[0:6]
    T = FT_perm[6:12]
    
    if wall:
      U_perm = self.mobility_trans_times_force_wall(pair_r_vecs, F, eta, a, periodic_length=L) + self.mobility_trans_times_torque_wall(pair_r_vecs, T, eta, a, periodic_length=L)
      W_perm = self.mobility_rot_times_force_wall(pair_r_vecs, F, eta, a, periodic_length=L) + self.mobility_rot_times_torque_wall(pair_r_vecs, T, eta, a, periodic_length=L)
    else:
      U_perm = self.mobility_trans_times_force(pair_r_vecs, F, eta, a, periodic_length=L) + self.mobility_trans_times_torque(pair_r_vecs, T, eta, a, periodic_length=L)
      W_perm = self.mobility_rot_times_force(pair_r_vecs, F, eta, a, periodic_length=L) + self.mobility_rot_times_torque(pair_r_vecs, T, eta, a, periodic_length=L)
    
    UW_perm = np.concatenate((U_perm,W_perm),axis=0)
    UW = np.dot(P,UW_perm)
    
    return UW
  
  
  def Self_MB_numba(self, FT, r, eta, a, wall=True, L=None):
    ''' 
    % numba mobility mult
    '''
    
    F = FT[0:3]
    T = FT[3:6]
    
    if wall:
      U = self.mobility_trans_times_force_wall(r, F, eta, a, periodic_length=L) + self.mobility_trans_times_torque_wall(r, T, eta, a, periodic_length=L)
      W = self.mobility_rot_times_force_wall(r, F, eta, a, periodic_length=L) + self.mobility_rot_times_torque_wall(r, T, eta, a, periodic_length=L)
    else:
      U = self.mobility_trans_times_force(r, F, eta, a, periodic_length=L) + self.mobility_trans_times_torque(r, T, eta, a, periodic_length=L)
      W = self.mobility_rot_times_force(r, F, eta, a, periodic_length=L) + self.mobility_rot_times_torque(r, T, eta, a, periodic_length=L)
    
    UW = np.concatenate((U,W),axis=0)
    
    return UW
  
  def Resist_Method(self, r_i, r_j, eta, a, Type='AT', L=None):
    ''' 
    % AT_Resist computes the near-field lubrication resistance matrix for a pair of
    % identical spheres from the scalars in Adam Townsend's paper and
    % Mathmatica code.
    '''
    R_i = r_i
    R_j = r_j
    r = R_j-R_i
    r = self.project_to_periodic_image(r, L)
    r *= (1./a)
    r_norm = np.linalg.norm(r)
    r_hat = r/r_norm

    if Type=='WS':
      Xa, Ya, Yb, Xc, Yc = self.WS_Resist(r_norm)
      inv = True
    elif Type=='JO':  
      Xa, Ya, Yb, Xc, Yc = self.JO_Resist(r_norm,1)
      inv = False
    elif Type=='JOR':
      Xa, Ya, Yb, Xc, Yc = self.JO_Resist_interp(r_norm)
      inv = False
    else: 
      Xa, Ya, Yb, Xc, Yc = self.AT_Resist(r_norm)
      inv = False
      
    squeezeMat = np.outer(r_hat, r_hat)
    shearMat = np.eye(3) - squeezeMat
    vortMat = np.array([[0.0,    r_hat[2], -r_hat[1]],
                        [-r_hat[2], 0.0,    r_hat[0]],
                        [r_hat[1], -r_hat[0], 0.0]])
    
    if inv:
      A_factor = 1.0 / (6*np.pi*eta*a)
      B_factor = 1.0 / (6*np.pi*eta*a**2)
      C_factor = 1.0 / (6*np.pi*eta*a**3)
    else:
      A_factor = (6*np.pi*eta*a)
      B_factor = (6*np.pi*eta*a**2)
      C_factor = (6*np.pi*eta*a**3)
    
    A = A_factor*(np.kron(Xa, squeezeMat) + np.kron(Ya, shearMat))
    B = B_factor*np.kron(Yb, vortMat)
    C = C_factor*(np.kron(Xc, squeezeMat) + np.kron(Yc, shearMat))
    
    P = np.kron(np.array([[1., 0., 0., 0.],[0., 0., 1., 0.],[0., 1., 0., 0.],[0., 0., 0., 1.]]), np.eye(3))
    ResistanceMix = np.block([[A, B],[B.T, C]])
    Resistance = np.dot(P,np.dot(ResistanceMix,P))
    
    if inv:
      Resistance = np.linalg.pinv(Resistance)
    
    return Resistance
    
  def pair_resistance_sup(self, eta, a, cutoff, L=None):
    '''
    Return the lubrication matrix for bodies given a method for the pair resistance
    '''
    num_particles = len(self.bodies)
    R_sup = np.array([np.zeros(6*num_particles) for _ in range(6*num_particles)])
    for j in range(num_particles-1):
      for k in range(j+1, num_particles):
	s1 = self.bodies[j].location
	s2 = self.bodies[k].location
	r = s1 - s2
	r = self.project_to_periodic_image(r, L)
        r_norm = np.linalg.norm(r)
        if r_norm < cutoff*a:
	  R = self.Resist(s1, s2, eta, a, L)
	  
	  R_sup[(j*6):(j*6 + 6), (j*6):(j*6 + 6)] += R[0:6, 0:6]
	  R_sup[(j*6):(j*6 + 6), (k*6):(k*6 + 6)] += R[0:6, 6:12]
	  R_sup[(k*6):(k*6 + 6), (j*6):(j*6 + 6)] += R[6:12, 0:6]
	  R_sup[(k*6):(k*6 + 6), (k*6):(k*6 + 6)] += R[6:12, 6:12]
	  
	  
    # add wall corrections
    for j in range(num_particles):
      s1 = self.bodies[j].location
      h = max(s1[2],a*1.0001) # applied max here
      #if h < 2.5*a: 
      R_wall = self.Lub_Resist_Wall(h, eta, a)
      R_sup[(j*6):(j*6 + 6), (j*6):(j*6 + 6)] += R_wall
      
    return R_sup
  
  def pair_resistance_sup_tree(self, eta, a, cutoff, L=None):
    '''
    Return the lubrication matrix for bodies given a method for the pair resistance
    '''
    num_particles = len(self.bodies)
    r_locs = np.array([b.location for b in self.bodies])
    r_tree = spatial.cKDTree(r_locs,boxsize=L)
    
    R_sup = np.array([np.zeros(6*num_particles) for _ in range(6*num_particles)])
    for j in range(num_particles):
      s1 = r_locs[j,:]
      idx = r_tree.query_ball_point(s1,r=cutoff*a)
      idx_trim = [i for i in idx if i > j]
      for k in idx_trim:
	s2 = r_locs[k,:]
	r = s1 - s2
	r = self.project_to_periodic_image(r, L)
	r_norm = np.linalg.norm(r)
	if r_norm < a*cutoff:
	  #print j
	  R = self.Resist(s1, s2, eta, a, L)
	  
	  R_sup[(j*6):(j*6 + 6), (j*6):(j*6 + 6)] += R[0:6, 0:6]
	  R_sup[(j*6):(j*6 + 6), (k*6):(k*6 + 6)] += R[0:6, 6:12]
	  R_sup[(k*6):(k*6 + 6), (j*6):(j*6 + 6)] += R[6:12, 0:6]
	  R_sup[(k*6):(k*6 + 6), (k*6):(k*6 + 6)] += R[6:12, 6:12]
	  
	  
    # add wall corrections
    for j in range(num_particles):
      s1 = self.bodies[j].location
      h = max(s1[2],a*1.0001) # applied max here
      #if h < 2.5*a: 
      R_wall = self.Lub_Resist_Wall(h, eta, a)
      R_sup[(j*6):(j*6 + 6), (j*6):(j*6 + 6)] += R_wall
	
    return R_sup
  
  def pair_resistance_sup_coo_to_csr(self, eta, a, cutoff, L=None):
    '''
    Return the lubrication matrix for bodies given a method for the pair resistance
    '''
    
    num_particles = len(self.bodies)
    r_locs = np.array([b.location for b in self.bodies])
    r_tree = spatial.cKDTree(r_locs,boxsize=L)
    
    m_eps = 1e-12
    
    R_sub_mats = []
    rows = []
    cols = []
    # add wall corrections
    for j in range(num_particles):
      s1 = self.bodies[j].location
      h = max(s1[2],a*1.0001) # applied max here
      R_wall = self.Lub_Resist_Wall(h, eta, a)
      #if(j == 0):
	#print("Wall: ")
	#print(R_wall)
      (row,col) = np.nonzero(np.abs(R_wall)>m_eps)
      R_wall_nz = R_wall[row,col]
      R_sub_mats.append(R_wall_nz.flatten())
      row += j*6
      col += j*6
      rows.append(row)
      cols.append(col)
      
    # add particle corrections  
    for j in range(num_particles):
      s1 = r_locs[j,:]
      idx = r_tree.query_ball_point(s1,r=cutoff*a)
      idx_trim = [i for i in idx if i > j]
      for k in idx_trim:
	s2 = r_locs[k,:]
	r = s1 - s2
	r = self.project_to_periodic_image(r, L)
	r_norm = np.linalg.norm(r)
	if r_norm < a*cutoff: 
	  #print j
	  R = self.Resist(s1, s2, eta, a, L)
	  
	  Rjj = R[0:6, 0:6]
	  Rkk = R[6:12, 6:12]
	  Rjk = R[0:6, 6:12]
	  Rkj = R[6:12, 0:6]
	  
	  #if(j == 0):
	    #np.set_printoptions(precision=5, suppress=True)
	    #print(-r/r_norm)
	    #print(r_norm)
	    #print(Rjj)
	  
	  (row,col) = np.nonzero(np.abs(Rjj)>m_eps)
	  R_nz = Rjj[row,col]
	  R_sub_mats.append(R_nz.flatten())
	  row += j*6
	  col += j*6
	  rows.append(row)
	  cols.append(col)	
	  
	  (row,col) = np.nonzero(np.abs(Rkk)>m_eps)
	  R_nz = Rkk[row,col]
	  R_sub_mats.append(R_nz.flatten())
	  row += k*6
	  col += k*6
	  rows.append(row)
	  cols.append(col)
	  
	  (row,col) = np.nonzero(np.abs(Rjk)>m_eps)
	  R_nz = Rjk[row,col]
	  R_sub_mats.append(R_nz.flatten())
	  row += j*6
	  col += k*6
	  rows.append(row)
	  cols.append(col)
	  
	  (row,col) = np.nonzero(np.abs(Rkj)>m_eps)
	  R_nz = Rkj[row,col]
	  R_sub_mats.append(R_nz.flatten())
	  row += k*6
	  col += j*6
	  rows.append(row)
	  cols.append(col)
	  
    
    row = np.concatenate(rows)
    col = np.concatenate(cols)
    data = np.concatenate(R_sub_mats)
    R_coo = sp.coo_matrix((data, (row, col)), shape=(6*num_particles, 6*num_particles)) 
    
    return R_coo.tocsc()
  
  def pair_resistance_sup_wall_coo_to_csr(self, eta, a, cutoff, h_cut =1.5, L=None):
    '''
    Return the lubrication matrix for bodies given a method for the pair resistance
    '''
    
    num_particles = len(self.bodies)
    r_locs = np.array([b.location for b in self.bodies])
    r_tree = spatial.cKDTree(r_locs,boxsize=L)
    
    m_eps = 1e-12
    
    R_sub_mats = []
    rows = []
    cols = []
    # add wall corrections
    for j in range(num_particles):
      s1 = self.bodies[j].location
      h = max(s1[2],a*1.0001) # applied max here
      if(h < h_cut*a):
	continue
      R_wall = self.Lub_Resist_Wall(h, eta, a)
      (row,col) = np.nonzero(np.abs(R_wall)>m_eps)
      R_wall_nz = R_wall[row,col]
      R_sub_mats.append(R_wall_nz.flatten())
      row += j*6
      col += j*6
      rows.append(row)
      cols.append(col)
    
    row = np.concatenate(rows)
    col = np.concatenate(cols)
    data = np.concatenate(R_sub_mats)
    R_coo = sp.coo_matrix((data, (row, col)), shape=(6*num_particles, 6*num_particles)) 
    
    return R_coo.tocsc()
  
  
  
  def pair_resistance_sup_lil_to_csr(self, eta, a, cutoff, L=None):
    '''
    Return the lubrication matrix for bodies given a method for the pair resistance
    '''
    '''
    Return the lubrication matrix for bodies given a method for the pair resistance
    '''
    num_particles = len(self.bodies)
    r_locs = np.array([b.location for b in self.bodies])
    r_tree = spatial.cKDTree(r_locs,boxsize=L)
    
    R_sup = sp.lil_matrix((6*num_particles, 6*num_particles))
    for j in range(num_particles):
      s1 = r_locs[j,:]
      idx = r_tree.query_ball_point(s1,r=cutoff*a)
      idx_trim = [i for i in idx if i > j]
      for k in idx_trim:
	s2 = r_locs[k,:]
	r = s1 - s2
	r = self.project_to_periodic_image(r, L)
	r_norm = np.linalg.norm(r)
	if r_norm < a*cutoff:
	  #print j
	  R = self.Resist(s1, s2, eta, a, L)
	  
	  R_sup[(j*6):(j*6 + 6), (j*6):(j*6 + 6)] += R[0:6, 0:6]
	  R_sup[(j*6):(j*6 + 6), (k*6):(k*6 + 6)] += R[0:6, 6:12]
	  R_sup[(k*6):(k*6 + 6), (j*6):(j*6 + 6)] += R[6:12, 0:6]
	  R_sup[(k*6):(k*6 + 6), (k*6):(k*6 + 6)] += R[6:12, 6:12]
	  
	  
    # add wall corrections
    for j in range(num_particles):
      s1 = self.bodies[j].location
      h = max(s1[2],a*1.0001) # applied max here
      #if h < 2.5*a: 
      R_wall = self.Lub_Resist_Wall(h, eta, a)
      R_sup[(j*6):(j*6 + 6), (j*6):(j*6 + 6)] += R_wall
    
    return R_sup.tocsc()
  
  def pair_resistance_mult_tree(self, F, eta, a, cutoff, L=None):
    '''
    Return the lubrication matrix for bodies given a method for the pair resistance
    '''
    #print "SUP TREE MULT"
    
    num_particles = len(self.bodies)
    r_locs = np.array([b.location for b in self.bodies])
    r_tree = spatial.cKDTree(r_locs,boxsize=L)
    
    U = 0*F
    
    for j in range(num_particles):
      s1 = r_locs[j,:]
      idx = r_tree.query_ball_point(s1,r=a*cutoff)
      idx_trim = [i for i in idx if i > j]
      for k in idx_trim:
	s2 = r_locs[k,:]
	r = s1 - s2
	r = self.project_to_periodic_image(r, L)
	r_norm = np.linalg.norm(r)
	if r_norm < a*cutoff:
	  #print j
	  R = self.Resist(s1, s2, eta, a, L)
	  F_j = F[(j*6):(j*6 + 6)]
	  F_k = F[(k*6):(k*6 + 6)]
	  
	  U[(j*6):(j*6 + 6)] += np.dot(R[0:6, 0:6],F_j) + np.dot(R[0:6, 6:12],F_k)
	  U[(k*6):(k*6 + 6)] += np.dot(R[6:12, 0:6],F_j) + np.dot(R[6:12, 6:12],F_k)
	  
    # add wall corrections
    for j in range(num_particles):
      s1 = self.bodies[j].location
      h = max(s1[2],a*1.0001) # applied max here
      #if h < 2.5*a:
      F_j = F[(j*6):(j*6 + 6)]
      R_wall = self.Lub_Resist_Wall(h, eta, a)
      U[(j*6):(j*6 + 6)] += np.dot(R_wall,F_j)
	  
    return U

  def pair_resistance_MB_coo_to_csr(self, eta, a, cutoff, L=None):
    '''
    Return the lubrication matrix for bodies given a method for the pair resistance
    '''
    
    num_particles = len(self.bodies)
    r_locs = np.array([b.location for b in self.bodies])
    r_tree = spatial.cKDTree(r_locs,boxsize=L)
    
    R_sub_mats = []
    rows = []
    cols = []
    # add wall corrections
    for j in range(num_particles):
      s1 = self.bodies[j].location
      h = max(s1[2],a*1.0001) # applied max here
      R_wall = self.Lub_Resist_Wall_MB(h, eta, a)
      (row,col) = np.nonzero(R_wall)
      R_wall_nz = R_wall[row,col]
      R_sub_mats.append(R_wall_nz.flatten())
      row += j*6
      col += j*6
      rows.append(row)
      cols.append(col)
      
    # add particle corrections  
    for j in range(num_particles):
      s1 = r_locs[j,:]
      idx = r_tree.query_ball_point(s1,r=cutoff*a)
      idx_trim = [i for i in idx if i > j]
      for k in idx_trim:
	s2 = r_locs[k,:]
	r = s1 - s2
	r = self.project_to_periodic_image(r, L)
	r_norm = np.linalg.norm(r)
	if r_norm < a*cutoff:
	  #print j
	  R = self.Resist_MB(s1, s2, eta, a, inv = False, L=L)
	  Rjj = R[0:6, 0:6]
	  Rkk = R[6:12, 6:12]
	  Rjk = R[0:6, 6:12]
	  Rkj = R[6:12, 0:6]
	  
	  (row,col) = np.nonzero(Rjj)
	  R_nz = Rjj[row,col]
	  R_sub_mats.append(R_nz.flatten())
	  row += j*6
	  col += j*6
	  rows.append(row)
	  cols.append(col)	
	  
	  (row,col) = np.nonzero(Rkk)
	  R_nz = Rkk[row,col]
	  R_sub_mats.append(R_nz.flatten())
	  row += k*6
	  col += k*6
	  rows.append(row)
	  cols.append(col)
	  
	  (row,col) = np.nonzero(Rjk)
	  R_nz = Rjk[row,col]
	  R_sub_mats.append(R_nz.flatten())
	  row += j*6
	  col += k*6
	  rows.append(row)
	  cols.append(col)
	  
	  (row,col) = np.nonzero(Rkj)
	  R_nz = Rkj[row,col]
	  R_sub_mats.append(R_nz.flatten())
	  row += k*6
	  col += j*6
	  rows.append(row)
	  cols.append(col)
	  
    
    row = np.concatenate(rows)
    col = np.concatenate(cols)
    data = np.concatenate(R_sub_mats)
    R_coo = sp.coo_matrix((data, (row, col)), shape=(6*num_particles, 6*num_particles)) 
    
    return R_coo.tocsc()  
  
  def pair_resistance_MB_wall_coo_to_csr(self, eta, a, cutoff, h_cut =1.5, L=None):
    '''
    Return the lubrication matrix for bodies given a method for the pair resistance
    '''
    
    num_particles = len(self.bodies)
    r_locs = np.array([b.location for b in self.bodies])
    r_tree = spatial.cKDTree(r_locs,boxsize=L)
    
    m_eps = 1e-12
    
    R_sub_mats = []
    rows = []
    cols = []
    # add wall corrections
    for j in range(num_particles):
      s1 = self.bodies[j].location
      h = max(s1[2],a*1.0001) # applied max here
      if(h < h_cut*a):
	continue
      R_wall = self.Lub_Resist_Wall_MB(h, eta, a)
      (row,col) = np.nonzero(np.abs(R_wall)>m_eps)
      R_wall_nz = R_wall[row,col]
      R_sub_mats.append(R_wall_nz.flatten())
      row += j*6
      col += j*6
      rows.append(row)
      cols.append(col)
    
    row = np.concatenate(rows)
    col = np.concatenate(cols)
    data = np.concatenate(R_sub_mats)
    R_coo = sp.coo_matrix((data, (row, col)), shape=(6*num_particles, 6*num_particles)) 
    
    return R_coo.tocsc()

  def pair_resistance_MB_lil_to_csr(self, eta, a, cutoff, L=None):
    '''
    Return the lubrication matrix for bodies given a method for the pair resistance
    '''
    '''
    Return the lubrication matrix for bodies given a method for the pair resistance
    '''
    num_particles = len(self.bodies)
    r_locs = np.array([b.location for b in self.bodies])
    r_tree = spatial.cKDTree(r_locs,boxsize=L)
    
    R_MB = sp.lil_matrix((6*num_particles, 6*num_particles))
    for j in range(num_particles):
      s1 = r_locs[j,:]
      idx = r_tree.query_ball_point(s1,r=cutoff*a)
      idx_trim = [i for i in idx if i > j]
      for k in idx_trim:
	s2 = r_locs[k,:]
	r = s1 - s2
	r = self.project_to_periodic_image(r, L)
	r_norm = np.linalg.norm(r)
	if r_norm < a*cutoff:
	  #print j
	  R = self.Resist_MB(s1, s2, eta, a, inv = False, L=L)
	  
	  R_MB[(j*6):(j*6 + 6), (j*6):(j*6 + 6)] += R[0:6, 0:6]
	  R_MB[(j*6):(j*6 + 6), (k*6):(k*6 + 6)] += R[0:6, 6:12]
	  R_MB[(k*6):(k*6 + 6), (j*6):(j*6 + 6)] += R[6:12, 0:6]
	  R_MB[(k*6):(k*6 + 6), (k*6):(k*6 + 6)] += R[6:12, 6:12]
	  
	  
    # add wall corrections
    for j in range(num_particles):
      s1 = self.bodies[j].location
      h = max(s1[2],a*1.0001) # applied max here
      #if h < 2.5*a: 
      R_wall = self.Lub_Resist_Wall_MB(h, eta, a)
      R_MB[(j*6):(j*6 + 6), (j*6):(j*6 + 6)] += R_wall
    
    return R_MB.tocsc()
  
  
  def pair_resistance_mult_MB_tree(self, F, eta, a, cutoff, L=None):
    '''
    Return the lubrication matrix for bodies given a method for the pair resistance
    '''
    #print "MB TREE MULT"
    #print L
    num_particles = len(self.bodies)
    r_locs = np.array([b.location for b in self.bodies])
    r_tree = spatial.cKDTree(r_locs,boxsize=L)
    
    U = 0*F
    
    near_wall = []
    
    for j in range(num_particles):
      s1 = r_locs[j,:]
      h_j = r_locs[j,2]
      idx = r_tree.query_ball_point(s1,r=a*cutoff)
      idx_trim = [i for i in idx if i > j]
      for k in idx_trim:
	s2 = r_locs[k,:]
	h_k = r_locs[k,2]
	r = s1 - s2
	r = self.project_to_periodic_image(r, L)
	r_norm = np.linalg.norm(r)
	if r_norm < a*cutoff:
	  #print j
	  F_j = F[(j*6):(j*6 + 6)]
	  F_k = F[(k*6):(k*6 + 6)]
	  F_jk = np.concatenate([F_j,F_k])
	  
 	  R = self.Resist_MB(s1, s2, eta, a, inv = False, L=L)
 	  U[(j*6):(j*6 + 6)] += np.dot(R[0:6, 0:6],F_j) + np.dot(R[0:6, 6:12],F_k)
	  U[(k*6):(k*6 + 6)] += np.dot(R[6:12, 0:6],F_j) + np.dot(R[6:12, 6:12],F_k)
 	  

	  
	  
    for j in range(num_particles): #near_wall
      h = r_locs[j,2]
      h = max(h,a*1.0001)
      F_j = F[(j*6):(j*6 + 6)]
      Res_MB_wall = self.Lub_Resist_Wall_MB(h, eta, a)
      U[(j*6):(j*6 + 6)] += np.dot(Res_MB_wall,F_j)  
	  
    return U
  
  
  def pair_resistance_sup_llc(self, eta, a, cutoff, *args, **kwargs):
    '''
    Return the lubrication matrix for bodies given a method for the pair resistance
    '''
    print "NOT WORKING FOR PERIODIC"
    num_particles = len(self.bodies)
    r_locs = np.array([b.location for b in self.bodies])
    llc=LLC(r_locs)
    llc.make_particle_linked_lists(cutoff, 0)
    R_sup = np.array([np.zeros(6*num_particles) for _ in range(6*num_particles)])
    for j in range(num_particles):
      s1 = r_locs[j,:]
      idx = llc.query_particle(j)
      idx = idx.astype(int)
      idx_trim = [i for i in idx if i > j]
      if not idx_trim:
	continue
      for k in idx_trim:
	#print str(j) + ',' + str(k)
	s2 = r_locs[k,:]
	r = s1 - s2
	r_norm = np.linalg.norm(r)
	if r_norm < a*cutoff:
	  #print j
	  R = self.Resist(s1, s2, eta, a, L)
	  
	  R_sup[(j*6):(j*6 + 6), (j*6):(j*6 + 6)] += R[0:6, 0:6]
	  R_sup[(j*6):(j*6 + 6), (k*6):(k*6 + 6)] += R[0:6, 6:12]
	  R_sup[(k*6):(k*6 + 6), (j*6):(j*6 + 6)] += R[6:12, 0:6]
	  R_sup[(k*6):(k*6 + 6), (k*6):(k*6 + 6)] += R[6:12, 6:12]
	  
    # add wall corrections
    for j in range(num_particles):
      s1 = self.bodies[j].location
      h = max(s1[2],a*1.0001) # applied max here
#      if h < 2.5*a:
      R_wall = self.Lub_Resist_Wall(h, eta, a)
      R_sup[(j*6):(j*6 + 6), (j*6):(j*6 + 6)] += R_wall
	
    return R_sup
  
##########################################################################################
#
# solvers
#
##########################################################################################
  
  def Lubrucation_operator_mult(self, X, eta, a, cutoff, L=None):
    '''
    Return the lubrication matrix for bodies given a method for the pair resistance
    '''
    start = time.time()
    num_particles = len(self.bodies)
    r_vecs = np.array([b.location for b in self.bodies])
    
    Forces = X[0:6*num_particles]
    Lagrange = X[6*num_particles::]
    
    FT = Forces.reshape(num_particles,6)
    F = FT[:,0:3].flatten()
    T = FT[:,3:6].flatten()
    
    
    U = self.mobility_trans_times_force_wall(r_vecs, F, eta, a, periodic_length=L) + self.mobility_trans_times_torque_wall(r_vecs, T, eta, a, periodic_length=L)
    W = self.mobility_rot_times_force_wall(r_vecs, F, eta, a, periodic_length=L) + self.mobility_rot_times_torque_wall(r_vecs, T, eta, a, periodic_length=L)
    
    UW = np.concatenate((U.reshape(num_particles,3),W.reshape(num_particles,3)),axis=1)
    Mob_U = UW.flatten()
    
    Lub_U = self.pair_resistance_mult_tree(Lagrange, eta, a, cutoff, L) - self.pair_resistance_mult_MB_tree(Lagrange, eta, a, cutoff, L)

    
    out_1 = Mob_U - Lagrange
    out_2 = -Lub_U - Forces
    out = np.concatenate((out_1, out_2))
    end = time.time()
    #print 'time for mult op: '+ str((end - start))
    
    return out
  
  
  def Wall_Mobility_Mult(self, X, eta, a,L=None):
    '''
    Return the lubrication matrix for bodies given a method for the pair resistance
    '''
    start = time.time()
    num_particles = len(self.bodies)
    r_vecs = np.array([b.location for b in self.bodies])
    
    FT = X.reshape(num_particles,6)
    F = FT[:,0:3].flatten()
    T = FT[:,3:6].flatten()
    
    U = self.mobility_trans_times_force_wall(r_vecs, F, eta, a, periodic_length=L) + self.mobility_trans_times_torque_wall(r_vecs, T, eta, a, periodic_length=L)
    W = self.mobility_rot_times_force_wall(r_vecs, F, eta, a, periodic_length=L) + self.mobility_rot_times_torque_wall(r_vecs, T, eta, a, periodic_length=L)
    
    UW = np.concatenate((U.reshape(num_particles,3),W.reshape(num_particles,3)),axis=1)
    Mob_U = UW.flatten()

    out = Mob_U
    end = time.time()
    #print 'time for mult op: '+ str((end - start))
    
    return out
  
  def Lub_Mobility_Mult(self, X, eta, a, cutoff, R_MB_csc, R_sup_csc, L=None):
    '''
    Return the lubrication matrix for bodies given a method for the pair resistance
    '''
    start = time.time()
    Delta_R = R_sup_csc.dot(X) - R_MB_csc.dot(X) #self.pair_resistance_mult_tree(X, eta, a, cutoff, L) - self.pair_resistance_mult_MB_tree(X, eta, a, cutoff, L)
    end = time.time()
    print 'time for DR mult : '+ str((end - start))
    
    start = time.time()
    M_Delta_R = self.Wall_Mobility_Mult(Delta_R, eta, a, L)
    out = X + M_Delta_R
    end = time.time()
    print 'time for M mult : '+ str((end - start))
    
    return out  
  
  
  def M_DR_Mult(self, X, eta, a, cutoff, L=None):
    '''
    Return the lubrication matrix for bodies given a method for the pair resistance
    '''
    start = time.time()
    
    #Delta_R = self.pair_resistance_mult_tree(X, eta, a, cutoff) - self.pair_resistance_mult_MB_tree(X, eta, a, cutoff)
    #M_Delta_R = self.Wall_Mobility_Mult(Delta_R, eta, a)
    
    M_X = self.Wall_Mobility_Mult(X, eta, a, L)
    M_Delta_R = self.pair_resistance_mult_tree(M_X, eta, a, cutoff, L) - self.pair_resistance_mult_MB_tree(M_X, eta, a, cutoff, L)
    

    out = X + M_Delta_R
    end = time.time()
    #print 'time for mult op: '+ str((end - start))
    
    return out 
    
  def Alt_PC(self, X, eta, a, cutoff, L=None,tol_in=1e-8,its_in=200,R_MB_csc=None,R_fact=None):
    '''
    methods:
    '''
    #print "ALT PC"
    start = time.time()
    num_particles = len(self.bodies)
    #r_vecs = np.array([b.location for b in self.bodies])

    
    RHS = R_MB_csc.dot(X) #self.pair_resistance_mult_MB_tree(X, eta, a, cutoff, L)
    Y_F = R_fact(RHS)
    #Y_F = spla.spsolve(R_sup, RHS)
    #(Y_F, info_precond) = spla.cg(R_sup,RHS, tol=tol_in, maxiter=its_in)
    #from cuSOLVER_test import cuspsolve
    #Y_F = cuspsolve(R_sup, RHS)

    #counter_in = gmres_counter(print_residual=True)
    #linear_operator_partial = partial(self.pair_resistance_mult_tree, eta=eta, a=a, cutoff=cutoff, L=L)
    #def Regularized_operator(v):
	#return linear_operator_partial(v)#linear_operator_partial(linear_operator_partial(v)) + 1.0e-6*v
    
    #RHS = self.pair_resistance_mult_MB_tree(X, eta, a, cutoff, L)
    #A = spla.LinearOperator((6*num_particles, 6*num_particles), matvec = Regularized_operator, dtype='float64')
    #(Y_F, info_precond) = utils.gmres(A,RHS, restart = min(1000,6*num_particles-1), tol=tol_in, maxiter=its_in, callback = counter_in) #

      
    end = time.time()
    print 'time for PC op: '+ str((end - start))
    return Y_F
  
  def Lubrucation_alt_solve_PC(self, X, eta, a, cutoff, L=None, print_residual=False, its_in = 1000, tol_in = 1e-10):
    '''
    Solve the lubrication problem for bodies
    '''
    counter_in = gmres_counter(print_residual)
    RHS = X
    RHS_norm = np.linalg.norm(RHS)
    if RHS_norm > 0:
      RHS = RHS / RHS_norm
    num_particles = len(self.bodies)
    #linear_operator_partial = partial(self.Diag_Lub_Mobility_Mult_RM, eta=eta, a=a, cutoff=cutoff)
    
    #PC_operator_partial = self.Alt_PC
    #PC = spla.LinearOperator((6*num_particles, 6*num_particles), matvec = PC_operator_partial, dtype='float64')
    PC = None
    A = spla.LinearOperator((6*num_particles, 6*num_particles), matvec = linear_operator_partial, dtype='float64')
    (U_gmres, info_precond) = utils.gmres(A,RHS, restart = min(1000,6*num_particles-1),M=PC,PC_side='right', tol=tol_in, maxiter=its_in) #, callback = counter_in
    if RHS_norm > 0:
      U_gmres = U_gmres * RHS_norm
    #print 'number of GMRES iterations = '+str(counter_in.niter)
    #print counter_in.residuals
    return U_gmres, counter_in.residuals# 
  
  def Lubrucation_alt_solve(self, X, eta, a, cutoff, L=None, print_residual=False, its_out = 1000, tol_out=1e-10, PC_flag=True):
    '''
    Solve the lubrication problem for bodies
    '''
    counter_in = gmres_counter(print_residual)
    res_list = []
    RHS = self.Wall_Mobility_Mult(X, eta, a, L)
    RHS_norm = np.linalg.norm(RHS)
    if RHS_norm > 0:
      RHS = RHS / RHS_norm
    num_particles = len(self.bodies)
    
    start = time.time()
    R_sup = self.pair_resistance_sup_coo_to_csr(eta, a, cutoff, L=L)
    R_MB = self.pair_resistance_MB_coo_to_csr(eta, a, cutoff, L=L)
    end = time.time()
    print 'mat create time : '+ str((end - start))
    
    start = time.time()
    factor = cholesky(R_sup)
    end = time.time()
    print 'factor time : '+ str((end - start))
    
    linear_operator_partial = partial(self.Lub_Mobility_Mult, eta=eta, a=a, cutoff=cutoff, R_MB_csc=R_MB, R_sup_csc=R_sup, L=L)
    

    
    if PC_flag:
      #R_sup.tocsc()
      factor = cholesky(R_sup)
      PC_operator_partial = partial(self.Alt_PC, eta=eta, a=a, cutoff=cutoff,L=L,its_in=200,tol_in=1e-10, R_MB_csc=R_MB,R_fact=factor)
      PC = spla.LinearOperator((6*num_particles, 6*num_particles), matvec = PC_operator_partial, dtype='float64')
    else:
      PC = None
    A = spla.LinearOperator((6*num_particles, 6*num_particles), matvec = linear_operator_partial, dtype='float64')
    
    (U_gmres, info_precond) = pyamg.krylov.gmres(A,RHS, tol=tol_out,M=PC,maxiter=its_out, restrt=min(1000,6*num_particles-1), residuals=res_list)#utils.gmres(A,RHS, restart = 1000,M=PC,PC_side='right', tol=1e-10, maxiter=its, callback = counter_in) #
    if RHS_norm > 0:
      U_gmres = U_gmres * RHS_norm
    #print 'number of GMRES iterations = '+str(counter_in.niter)
    print res_list
    return U_gmres, res_list#
    
  def Inner_Solve(self, X, eta, a, cutoff,L=None, tol_in=1e-8,its_in=200 ):
    '''
    methods:
    '''
    start = time.time()
    num_particles = len(self.bodies)

    

    counter_in = gmres_counter(print_residual=True)
    RHS = X
    linear_operator_partial = partial(self.pair_resistance_mult_tree, eta=eta, a=a, cutoff=cutoff,L=L)
    A = spla.LinearOperator((6*num_particles, 6*num_particles), matvec = linear_operator_partial, dtype='float64')
    (Z, info_precond) = utils.gmres(A,RHS, restart = min(1000,6*num_particles-1), tol=tol_in, maxiter=its_in) 
    X_out = Z
    
    end = time.time()
    #print 'time for PC op: '+ str((end - start))
    return X_out, counter_in 
    
  def Lubrucation_PC(self, X, eta, a, cutoff, L=None, its=3, tol=1e-4):
    '''
    methods
    1) use gmres to approx solve schur system
    '''
    start = time.time()
    num_particles = len(self.bodies)
    
    a_rhs = X[0:6*num_particles]
    b_rhs = X[6*num_particles::]
    
    #Delta_R_a = self.pair_resistance_mult_tree(a_rhs, eta, a, cutoff, L) - self.pair_resistance_mult_MB_tree(a_rhs, eta, a, cutoff, L)
    #RHS = Delta_R_a - b_rhs
    #x, res  = self.Inner_Solve(RHS, eta, a, 4.5, L=L, its_in=its, tol_in=tol)
    #z = self.pair_resistance_mult_MB_tree(x, eta, a, cutoff, L)
    #y = -a_rhs - self.Wall_Mobility_Mult(z, eta, a, L)
      
    #RHS = -1.0*(self.Wall_Mobility_Mult(b_rhs, eta, a, L) + a_rhs)
    #RHS = self.pair_resistance_mult_MB_tree(RHS, eta, a, cutoff, L)
    RHS = -1.0*(self.pair_resistance_mult_MB_tree(a_rhs, eta, a, cutoff,L) + b_rhs)
    y, res  = self.Inner_Solve(RHS, eta, a, 4.5,L=L,its_in=its,tol_in=tol)
    Delta_R_y = self.pair_resistance_mult_tree(y, eta, a, cutoff, L) - self.pair_resistance_mult_MB_tree(y, eta, a, cutoff, L)
    x = -1.0*(Delta_R_y + b_rhs)
      
    Y = np.concatenate((x, y))
    end = time.time()
    #print 'time for PC op: '+ str((end - start))
    return Y
  
  def Lubrucation_PC_M_mult(self, X, eta, a, L=None):
    '''
    methods
    pretent that there is no DR 
    '''
    start = time.time()
    num_particles = len(self.bodies)
    r_vecs = np.array([b.location for b in self.bodies])
    
    Forces = X[0:6*num_particles]
    Lagrange = X[6*num_particles::]
    Y_F = -1.0*Lagrange
    
    FT = Y_F.reshape(num_particles,6)
    F = FT[:,0:3].flatten()
    T = FT[:,3:6].flatten()
    
    
    U = self.mobility_trans_times_force_wall(r_vecs, F, eta, a, periodic_length=L) + self.mobility_trans_times_torque_wall(r_vecs, T, eta, a, periodic_length=L)
    W = self.mobility_rot_times_force_wall(r_vecs, F, eta, a, periodic_length=L) + self.mobility_rot_times_torque_wall(r_vecs, T, eta, a, periodic_length=L)
    
    UW = np.concatenate((U.reshape(num_particles,3),W.reshape(num_particles,3)),axis=1)
    Y_L = -Forces+UW.flatten()
      
    Y = np.concatenate((Y_F, Y_L))
    end = time.time()
    #print 'time for PC op: '+ str((end - start))
    return Y

  def Swan_PC(self, X, eta, a, cutoff, L=None,tol_in=1e-8,its_in=200):
    '''
    methods:
    '''
    start = time.time()
    num_particles = len(self.bodies)
    
    a_rhs = X[0:6*num_particles]
    b_rhs = X[6*num_particles::]

    x_temp = a_rhs

    counter_in = gmres_counter(print_residual=True)
    R_sup = partial(self.pair_resistance_mult_tree, eta=eta, a=a, cutoff=cutoff, L=L)
    R_MB = partial(self.pair_resistance_mult_MB_tree, eta=eta, a=a, cutoff=cutoff, L=L)
    def partial_operator(v):
	return R_MB(v) - R_sup(v) - v 
    
    RHS = a_rhs + b_rhs
    A = spla.LinearOperator((6*num_particles, 6*num_particles), matvec = partial_operator, dtype='float64')
    (y_temp, info_precond) = utils.gmres(A,RHS, restart = min(1000,6*num_particles-1), tol=tol_in, maxiter=its_in, callback = counter_in) #

    y = y_temp
    x = x_temp + y_temp
  
    Y = np.concatenate((x, y))
    end = time.time()
    #print 'time for PC op: '+ str((end - start))
    return Y


  def Lubrucation_solve(self, X, eta, a, cutoff, L=None):
    '''
    Solve the lubrication problem for bodies
    '''
    #counter_out = gmres_counter(print_residual = True)
    RHS_norm = np.linalg.norm(X)
    RHS = X
    res_list = []
    if RHS_norm > 0:
      RHS = RHS / RHS_norm
    num_particles = len(self.bodies)
    linear_operator_partial = partial(self.Lubrucation_operator_mult, eta=eta, a=a, cutoff=cutoff, L=L)
    PC_operator_partial = partial(self.Swan_PC, eta=eta, a=a, L=L, cutoff=cutoff,its_in=200,tol_in=1e-10) #
    #PC_operator_partial = partial(self.Lubrucation_PC, eta=eta, a=a, L=L, cutoff=cutoff,its=200,tol=1e-10) #
    #PC_operator_partial = partial(self.Lubrucation_PC_M_mult, eta=eta, a=a, L=L)
    A = spla.LinearOperator((2*6*num_particles, 2*6*num_particles), matvec = linear_operator_partial, dtype='float64')
    PC = spla.LinearOperator((2*6*num_particles, 2*6*num_particles), matvec = PC_operator_partial, dtype='float64')
    (U_gmres, info_precond) = pyamg.krylov.fgmres(A,RHS, tol=1e-10,M=PC,maxiter=1000, restrt=min(1000,6*num_particles-1), residuals=res_list) #, PC_side='right' #callback = counter_out
    if RHS_norm > 0:
      U_gmres = U_gmres * RHS_norm
      
    #print(np.linalg.norm(RHS-A*U_gmres,np.inf))
    #print 'number of GMRES iterations = '+str(counter_out.niter)
    print res_list
    return U_gmres, res_list
 
##########################################################################################
#
# utilities
#
##########################################################################################
  
  def Single_Blob_Resistance(self, eta, a, num_points, eps):
    '''
    Solve for the single blob wall correction resistance
    
    TODO: use this function in the multiblob mult routine. But also use this in the precontioner since you will need
    single blob inverses 
    '''
    
    e_0 = np.zeros(6)
    res_coef = np.empty((num_points+1,6))
    for j in range(num_points+1):
      print(j)
      z = (1.0001+(j)*eps) #(1.0001+(j)*eps)
      s1 = np.array([0.0, 0.0, z]) 
      s1 = s1[np.newaxis,:]
      Resistance_MB = np.zeros((6,6))
      linear_operator_partial = partial(self.Self_MB_numba, r = s1 , eta = (1.0/6.0/np.pi), a = 1.0, wall = True)
      A = spla.LinearOperator((6, 6), matvec = linear_operator_partial, dtype='float64')
      for i in range(6):
	e_i = 0.0*e_0
	e_i[i] = 1.0
	(R_i, info_precond) = spla.gmres(A,e_i, tol=1e-10)
	Resistance_MB[:,i] = R_i
      print(Resistance_MB)
      res_coef_j = np.array([z, Resistance_MB[2,2], Resistance_MB[0,0], Resistance_MB[4,0], Resistance_MB[5,5], Resistance_MB[3,3]])
      res_coef[j,:] = res_coef_j
    print(res_coef)
    name = '/home/bs162/LubricationCode/RigidMultiblobsWallLubrication/multi_bodies/Resistance_Coefs/res_scalars_wall_MB.txt'
    np.savetxt(name, res_coef, delimiter='  ')
  
    return res_coef
  
  
  def Single_Blob_Resistance_extend(self, num_points, eps):
    '''
    Solve for the single blob wall correction resistance
    
    TODO: use this function in the multiblob mult routine. But also use this in the precontioner since you will need
    single blob inverses 
    '''
    
    e_0 = np.zeros(6)
    res_coef = np.empty((num_points+1,6))
    k = -1
    for j in range(4502,4502+16*num_points+1,16): #range(1502,1502+2*num_points+1,2)
      print(j)
      k += 1
      z = (1.0001+(j)*eps) #(1.0001+(j)*eps)
      s1 = np.array([0.0, 0.0, z]) 
      s1 = s1[np.newaxis,:]
      Resistance_MB = np.zeros((6,6))
      linear_operator_partial = partial(self.Self_MB_numba, r = s1 , eta = (1.0/6.0/np.pi), a = 1.0, wall = True)
      A = spla.LinearOperator((6, 6), matvec = linear_operator_partial, dtype='float64')
      for i in range(6):
	e_i = 0.0*e_0
	e_i[i] = 1.0
	(R_i, info_precond) = spla.gmres(A,e_i, tol=1e-10)
	Resistance_MB[:,i] = R_i
      print(Resistance_MB)
      res_coef_j = np.array([z, Resistance_MB[2,2], Resistance_MB[0,0], Resistance_MB[4,0], Resistance_MB[5,5], Resistance_MB[3,3]])
      res_coef[k,:] = res_coef_j
    print(res_coef)
    name = '/home/bs162/LubricationCode/RigidMultiblobsWallLubrication/multi_bodies/Resistance_Coefs/res_scalars_wall_MB_extended_3.txt'
    np.savetxt(name, res_coef, delimiter='  ')
  
    return res_coef
  
  
  def Pair_Blob_Resistance_Free_Space(self, eta, a, num_points, eps):
    '''
    Solve for the single blob wall correction resistance
    
    TODO: use this function in the multiblob mult routine. But also use this in the precontioner since you will need
    single blob inverses 
    '''
    P = np.kron(np.array([[1., 0., 0., 0.],[0., 0., 1., 0.],[0., 1., 0., 0.],[0., 0., 0., 1.]]), np.eye(3))
    e_0 = np.zeros(12)
    res_coef = np.empty((2*num_points+2,6))
    for j in range(num_points+1):
      print(j)
      x = (2.0001-(j)*eps) #(1.0001+(j)*eps)
      s1 = np.array([x, 0.0, 0.0]) 
      s2 = np.array([0.0, 0.0, 0.0])
      pair_r_vecs = np.stack((s1, s2), axis=0)
      Mob_P = np.zeros((12,12))
      linear_operator_partial = partial(self.Pair_MB_numba, r_i = s1, r_j = s2, eta = (1.0/6.0/np.pi), a = 1.0, wall = False, L = np.array([0,0,0]))
      A = spla.LinearOperator((12,12), matvec = linear_operator_partial, dtype='float64')
      for i in range(12):
	e_i = 0.0*e_0
	e_i[i] = 1.0
	#(R_i, info_precond) = spla.gmres(A,e_i, tol=1e-10)
	R_i = A*e_i
	Mob_P[:,i] = R_i
      Mob_MB = np.dot(P,np.dot(Mob_P,P))
      Resistance_MB = np.linalg.pinv(Mob_MB)
      #print(Resistance_MB)
      res_coef_j_11 = np.array([x, Resistance_MB[0,0], Resistance_MB[1,1], Resistance_MB[4,11], Resistance_MB[9,9], Resistance_MB[11,11]])
      res_coef_j_12 = np.array([x, Resistance_MB[0,3], Resistance_MB[1,4], Resistance_MB[1,11], Resistance_MB[9,6], Resistance_MB[11,8]])
      #res_coef[2*j,:] = res_coef_j_11
      #res_coef[2*j+1,:] = res_coef_j_12
      res_coef[2*num_points+1-2*j-1,:] = res_coef_j_11
      res_coef[2*num_points+1-2*j,:] = res_coef_j_12
    #print(res_coef)
    #name = '/home/bs162/LubricationCode/RigidMultiblobsWallLubrication/multi_bodies/Resistance_Coefs/res_scalars_MB_1_negative.txt'
    name = '/home/bs162/LubricationCorrection/RigidMultiblobsWallLubrication/multi_bodies/Resistance_Coefs/res_scalars_MB_1_negative.txt'
    np.savetxt(name, res_coef, delimiter='  ')
  
    return res_coef
  
  
  def Pair_Blob_Resistance_Free_Space_Test(self, eta, a, num_points, eps):
    '''
    Solve for the single blob wall correction resistance
    
    TODO: use this function in the multiblob mult routine. But also use this in the precontioner since you will need
    single blob inverses 
    '''
    P = np.kron(np.array([[1., 0., 0., 0.],[0., 0., 1., 0.],[0., 1., 0., 0.],[0., 0., 0., 1.]]), np.eye(3))
    e_0 = np.zeros(12)
    res_coef = np.empty((2*num_points+2,6))
    for j in range(num_points+1):
      print(j)
      x = (2.0001+(j)*eps) #(1.0001+(j)*eps)
      s1 = np.array([x, 0.0, 0.0]) 
      s2 = np.array([0.0, 0.0, 0.0])
      pair_r_vecs = np.stack((s1, s2), axis=0)
      Mob_P = np.zeros((12,12))
      linear_operator_partial = partial(self.Pair_MB_numba, r_i = s1, r_j = s2, eta = eta, a = 1.0, wall = False)
      A = spla.LinearOperator((12,12), matvec = linear_operator_partial, dtype='float64')
      for i in range(12):
	e_i = 0.0*e_0
	e_i[i] = 1.0
	#(R_i, info_precond) = spla.gmres(A,e_i, tol=1e-10)
	R_i = A*e_i
	Mob_P[:,i] = R_i
      Mob_MB = np.dot(P,np.dot(Mob_P,P))
      Resistance_MB = np.linalg.pinv(Mob_MB)
      Test = self.Resist_MB(s1, s2, eta = eta, a = 1.0, inv = False, L=L)
      Test = np.dot(P,np.dot(Test,P))
      print((Resistance_MB)-(Test)) #np.linalg.norm  -
  
    return res_coef
  
  
  def Test_Single_Blob_Resistance(self, eta, a, num_points, eps):
    '''
    Solve for the single blob wall correction resistance
    
    TODO: use this function in the multiblob mult routine. But also use this in the precontioner since you will need
    single blob inverses 
    '''
    
    e_0 = np.zeros(6)
    for j in range(num_points+1):
      print(j)
      z = (1.0002+(j)*eps) #(1.0001+(j)*eps)
      s1 = np.array([0.0, 0.0, z]) 
      s1 = s1[np.newaxis,:]
      Resistance_MB = np.zeros((6,6))
      linear_operator_partial = partial(self.Self_MB_numba, r = s1 , eta = eta, a = a, wall = True)
      A = spla.LinearOperator((6, 6), matvec = linear_operator_partial, dtype='float64')
      for i in range(6):
	e_i = 0.0*e_0
	e_i[i] = 1.0
	(R_i, info_precond) = spla.gmres(A,e_i, tol=1e-10)
	Resistance_MB[:,i] = R_i
      Test_inv = self.Single_Blob_Mob_Wall(eta, a, z)#self.Lub_Resist_Wall_MB(z, eta, a)
      Test = np.linalg.pinv(Test_inv)
      print(np.linalg.norm(Resistance_MB-Test))
      
  def Single_Blob_Mob_Wall(self, eta, a, h):
    '''
    self mobility with wall
    '''
    hj = h/a
    invZi = 1.0 / hj
    invZi3 = invZi**3
    invZi4 = invZi**4
    invZi5 = invZi**5
    
    mob_fact_rw = 1.0 / (8.0 * np.pi * eta * a**3)
    mob_fact_tw = 1.0 / (8.0 * np.pi * eta * a**2)
    mob_fact_tf = 1.0 / (8.0 * np.pi * eta * a)
    M = np.eye(3)
    
    ## trans-trans block
    M_tf = 4.0/3.0*M
            
    M_tf[0,0] += -(9.0 * invZi - 2.0 * invZi3 + invZi5 ) / 12.0
    M_tf[1,1] += -(9.0 * invZi - 2.0 * invZi3 + invZi5 ) / 12.0
    M_tf[2,2] += -(9.0 * invZi - 4.0 * invZi3 + invZi5 ) / 6.0
    M_tf *= mob_fact_tf
    
    ## trans-rot/rot-trans block
    M_tw = 0.0*M
    M_rf = 0.0*M
    
    M_tw[0,1] -= - invZi4 * 0.125 # 3/24 = 0.125
    M_tw[1,0] -=   invZi4 * 0.125 # 3/24 = 0.125
    M_tw *= mob_fact_tw
    M_rf[0,1] += - invZi4 * 0.125 # 3/24 = 0.125
    M_rf[1,0] +=   invZi4 * 0.125 # 3/24 = 0.125
    M_rf *= mob_fact_tw
    
    ## rot-rot block
    M_rw = M
    
    M_rw[0,0] += - invZi3 * 0.3125 # 15/48 = 0.3125
    M_rw[1,1] += - invZi3 * 0.3125 # 15/48 = 0.3125
    M_rw[2,2] += - invZi3 * 0.125  # 3/24 = 0.125
    M_rw *= mob_fact_rw
    
    Mobility = np.block([[M_tf, M_tw],[M_rf, M_rw]])
    return Mobility
  
class gmres_counter(object):
  '''
  Callback generator to count iterations. 
  '''
  def __init__(self, print_residual = False):
    self.print_residual = print_residual
    self.niter = 0
    self.residuals = []
  def __call__(self, rk=None):
    self.niter += 1
    self.residuals.append(rk)
    if self.print_residual is True:
      if self.niter == 1:
	print('gmres =  0 1')
      print('gmres = ', self.niter, rk)